### Day 1

최소 뷰 2개 이상의 간단한 앱 만들기.

전자 명함느낌.
번호와 각종 정보가 다 담겨있어, 따로 번호나 인스타 교환을 할 필요가 없다.

**페인 포인트**
처음에 봤을때 연락처,인스타 어떤 걸 교환해야 하는지 고민된다.

***다이버 도감***
도감을 채운 러너와는 채팅, 약속 잡기 기능이 가능하다.
처음 만난 장소를 등록하여, 어디서 봤는지 까먹는 일 방지.

### 기능 명세서

1. 프로젝트 소개
2. 기술 스택
3. 기능 목록
4. 프로젝트 구조
5. 사용 방법
6. 예시

#### 1. 프로젝트 소개
해당 앱은 러너들끼리 정보 교환을 수월히 할 수 있게 도와주는 앱이며,
도감을 등록하기 위해서 상대방에게도 먼저 다가갈 수 있게 되고 다양한 정보를 도감의 정보로 쉽게 확인할 수 있다.

#### 2. 기술 스택
해당 프로젝트는 SwiftUI를 사용하여 개발되었습니다.
MultiPeer Connectivity(MPC) 프레임워크를 사용하여 통신을 구현하였습니다.

#### 3. 기능 목록
도감 등록
- [ ] 사용자로부터 정보를 입력받아 자신의 도감을 등록한다.

도감 교환
- [ ] 도감의 정보를 QR코드를 통해서 다른 사용자에게 공유한다.
- [ ] QR코드를 찍으면 상대의 정보가 자신의 도감에 등록된다.

도감 수정
- [ ] 사용자가 자신의 도감 내용을 수정한다.
- [ ] 다른 사용자의 도감에서 자신만 볼 수 있는 정보를 추가한다.

도감 업데이트
- [ ] 도감을 공유받으면 도감 목록에 새로 업데이트 된다.
- [ ] 등록 되어있는 도감 목록에서 정보가 수정되면, 해당 내용으로 도감이 업데이트 된다.
	- [ ] 도감내용이 수정되면 해당 도감을 추가한 사람에게 알림이 간다.
- [ ] 등록된 러너를 토대로 도감 현황과 달성률이 업데이트 된다.

도감 삭제
- [ ] 삭제하고 싶은 러너의 도감을 삭제한다.


#### 4. 프로젝트 구조
```
Diver Book/
ㄴ View/
	ㄴ LoadingView.swift
	ㄴ StartView.swift
	ㄴ MainView.swift
	ㄴ DetailView.swift
	ㄴ ChangeView.swift
	ㄴ 


```


### 유저 플로우

***User flow란 ?***
User가 수행하게 되는 작업 순서대로
이 **일련의 흐름**을 나타낸 것

**사용자가 사용하는 흐름**

***User flow를 만드는 것이란 ?***
앱을 사용하면서 달성하고자 하는 **목표**를 

>사용자가 최종목적에 도달하는 상태까지 수행하는 일련의 작업흐름을 구체적으로 명시하고
>이를 통해 각 단계에서 어떤 정보를 전달해야하는지 명확하게 정리할 수 있다.

**핵심 골**

만난 러너들을 도감에 모두 수집하기.

**Lo-fi**
적은 노력으로 아이디어를 검증할 수 있다.

**빠른 발산, 적은 비용**

### 아이디어

추가하지 않은 러너들을 ???로 표시하지 않고, 닉네임만 제공해준 뒤 주변에 알고있는 러너 수 까지 알 수 있게끔.
해당 러너의 정보는 등록해야 볼 수 있는 걸로.

도감에서 러너 리스트를 나열할 때, 추가한 러너들 순과 기본 닉네임 순 두 가지로 정렬할 수 있게끔 설정.


탭바를 
List | Chat | Profile
세 영역으로 구성하고, profile에 들어가면 나의 페이지와 qr코드 공유, 촬영 목록이 있음.

가장 베스트는 airdrop으로 주변 모든 사람과 프로필을 교환하는 방법.

랜덤한 동물을 ai로 생성해서 프로필 이미지 등록.


### 리팩토링 필요한 부분
박스 내부에 텍스트 올릴 때, overlay 대신 ZStack으로 텍스트 올리기.

##### ProfileDetailView
첫 번째 프로필 상자 우측 상단에 `Info`아이콘 넣어서 누르면 등록 순번이랑 등록 날짜 등등 정보 나오게 구상.

메모 부분 텍스트 필드 넣지 말고 해당 부분을 뷰로 구성해서 

이메일같이 텍스트 긴 부분은, 마우스 오버하면 작은 팝업으로 해서 전체 내용 나오게.
![[Pasted image 20250414111819.png]]

ProfileDetailView에서 전체 화면을 하나의 뷰로 구성하되, struct로 각각의 영역을 나눠서 main에서 합친다.
JSON파일에는 어떤 경로에 저장해야 할 지만 지시하고 로컬에 이미지를 저장.

### 데이터 특강
**데이터 모델링이란?**
- 데이터를 어떤 형식으로, 어떤 관계로 저장할지를 미리 설계하는 작업.
- 일관성 있는 데이터 구조를 만들기 위해

로컬에 데이터를 저장하는 방식으로는 `CoreData`, `SwiftData`, `UserDefaults`가 있다.

**UserDefaults**
앱의 기본 설정 저장소로 간단한 키-값 쌍으로 데이터를 저장한다.

**SwiftData**
SQLite기반의 앱 내부 DB이다.
객체 기반으로 데이터를 저장한다.


### 추가할 기능
#### 4/17 To-do List

**디테일 뷰**
- [ ] 메모 에디터 뷰 코드 이해하기
- [ ] @stateobject, @observedObject, @published, Combine 이해하기
- [ ] 디테일 뷰 구조 리팩터링하기
	- [ ] 배경 박스 공통으로 사용(요소에 따라서 크기 조절되는 박스
- [ ] 이미지 추가 기능 구현
- [ ] 네비게이션스택으로 홈 뷰 -> 디테일 뷰 이동 기능 구현

**마이 페이지**
- [ ] UI 모두 구현
- [ ] 기능 모두 구현

#### 4/18 To-do List
**탭 바**
- [ ] 탭 바 UI 구현
- [ ] 탭 바 기능 구현

**데이터 저장**
- [ ] swiftData로 데이터 저장하는 방법 공부
- [ ] QR코드 생성 및 전달 방식 구현(firebase or swiftData)
	- [ ] QR코드 UI 구현


#### 공통 목록
- [x] 디테일 페이지 및 모든 페이지에 새로운 profile model로 연결하기,
      새로 모델을 추가하여 my page 모델과 구분 지을지 고민마이 페이지 DB를 따로 만들어서,
      해당 페이지에서 만드는 데이터는 기존 데이터 수정만 하고 새로운 프로필이 생성되지 않게 하기

- [x] 탭 바 구현하여 페이지 이동하기
- [x] 모델에 데이터 올바르게 저장 안되는 에러 해결하기. (앱 삭제하니 해결)
- [x] 다른 사람 페이지에 앨범 이미지 추가 기능 구현
- [x] 홈 뷰에서 친구가 없는 경우 0명 화면 UI 적용.
- [x] 도감에서 프로필 삭제 기능 추가 (화면 하단 삭제 버튼 추가)
- [x] 데이터 교환 방법 공부하고 적용 (name drop?)
- [x] 해당 데이터 교환 방법에 맞게 페이지 디자인 하기(아니면 탭 바에서 공유버튼만 누르면 별도 화면 표시 없이 공유할 수 있게. 그리고 공유 완료되면 해당 프로필의 디테일 페이지로.
- [x] 검색 및 정렬 기능 구현
- [x] 화면 하단 흰색 없애기
- [ ] 공유 화면 figma에서 디자인한대로 고치기(토스 주변친구 UI 참고)
	- [x] view 그리기
	- [x] 친구 추가되는 위치 지정하기
	- [ ] 클릭하면 연결 신청 -> 연결중 로딩 표시 -> 연결되면 V 체크표시
	- [ ] 연결 요청 받으면 확인 눌러서 수락 | 거절 눌러서 수락
	- [ ] 공유하기 누르면 같은 세션 기기들에게 전송
	- [ ] 공유 하면 팝업으로 공유했다 알림
	- [ ] 공유 받으면 확인 눌러서 수락하여 받기 (리스트로 할지 개별 모두 확인으로 할지)

- [ ] NearBy Interaction 사용해서 유저간 거리 방향 받아오기
	- [ ] 2번째로 큰 원 기준으로 유저 위치와 방향에 맞춰 표기하기

- [ ] 마이 페이지에서 편집 버튼 눌러야 편집 모드로 들어가게 수정
	- [ ] return 누르면 다음 줄 입력으로 넘어가게
	- [ ] 아래 입력칸으로 갈 수록 화면 위로 올려서 키보드에 가리지 않게
	- [ ] 마이 페이지에서 수정 사항 실시간으로 자동 저장되게

- [ ] PeerID 로컬에서 닉네임 가져와서 설정하기
	- [ ] 스플래시 화면 View 만들기
	- [ ] 스플래시 화면에서 입력한 닉네임 자동으로 myPage닉네임으로 지정하기
	- [ ] deviceIDManager로 userDefaults에 닉네임 저장하기
	- [ ] 해당 닉네임으로 MyPeerID설정하기
	- [ ] MyPage에서 닉네임 변경하면 deviceID 재설정하기

- [ ] 앨범 뷰 페이지 형식으로 변경
- [ ] 이미지 중복 금지 추가
- [ ] 애니메이션 넣기 (버튼 클릭, 화면 전환, 삭제, 저장버튼)
	- [ ] 저장,삭제 버튼 누르면 팝업 띄워서 안내하기.
- [ ] 좋아요 기능 구현 (optional)


**섭 피드백**
공유의 유저 플로우가 명확하지가 않다.
- 토스 친구 화면처럼 구성하여 명확하게 하기

처음 닉네임을 입력할 수 있도록 유도하면 좋다.
- 닉네임이 등록되어 있지 않으면, 닉네임 입력하는 초기화면이 나오게 구성. 그리고 마이 페이지에 해당 닉네임만 바로 등록하기. 해당 화면에서 userDefaults에 닉네임을 입력해버리는 방법도 있음.


**MPC 관련**
- [x] MCpeerID이름을 프로필 이름으로 변경하기.
- [x] 하나의 기기가 여러 닉네임으로 나오는 에러 고치기 (기기 재부팅)
- [ ] 연결 요청 받을 때 닉네임만 나오게
	디바이스 매니저로 구현할 경우 UserDefaults에 이모지랑 닉네임 각각 설정하고, mpc서비스에서는 닉네임만 받아오고, sharingView에선 이모지를 받아오는 방법 고려.

**NameDrop 기능 구현**
Nearby Interaction(기기 간 근접성 감지 기능) 프레임워크를 통해서 기기 간 거리를 파악하고,

MultipeerConnectivity(로컬 P2P 네트워킹)을 통해서 데이터를 주고받는다.


### 개념 정리

#### MultiPeerConnectivity(MPC) 통신
**MultiPeerConnectivity(MPC)** 가 무엇일까 ?
근처에 있는 iOS/macOS 기기 끼리 직접 통신할 수 있게 해주는 프레임워크.

- Wi-Fi, 블루투스, Peer-toPeer Wi-Fi, USB연결을 통해 통신
- 메시지 기반 데이터 전송을 도와준다.

##### MPC 통신 흐름 요약
- **Peer(피어) 생성**: 각 기기는 자신만의 ID를 가짐.
    
- **세션 생성**: 피어들끼리 통신할 수 있는 채널을 열어둠.
    
- **탐색 or 광고**: 한쪽은 브라우저(MCNearbyServiceBrowser)로 주변을 검색, 다른 쪽은 광고자(MCNearbyServiceAdvertiser)로 자신을 알림.
    
- **초대 및 수락**: 한쪽이 상대 피어에게 연결 요청을 보냄, 수락되면 세션 연결됨.
     
- **데이터 전송**: 연결된 피어들 사이에 데이터, 파일, 스트림 등을 주고받음.

##### MPC 핵심 클래스 구조

|클래스|역할|
|---|---|
|`MCPeerID`|자신 또는 상대방 피어를 식별하는 ID|
|`MCSession`|연결된 피어 간에 데이터를 주고받는 통로|
|`MCNearbyServiceAdvertiser`|내가 주변 기기에 "나 여기 있어!" 하고 광고|
|`MCNearbyServiceBrowser`|주변에 있는 피어를 검색|
|`MCSessionDelegate`|데이터 수신, 연결 상태 변화 등을 처리|
|`MCNearbyServiceAdvertiserDelegate`|연결 요청 수신 처리|
|`MCNearbyServiceBrowserDelegate`|피어를 발견하거나 사라질 때 알림|

---

#####  통신 방식 정리

|역할|설명|
|---|---|
|**광고자(Advertiser)**|"내가 이 서비스를 제공하고 있어요!"라고 알림|
|**브라우저(Browser)**|주변을 검색해서 광고 중인 기기를 발견|
|**세션(Session)**|연결된 피어끼리 데이터 주고받는 통로|
|**초대(Invitation)**|브라우저가 광고자에게 연결 요청 보내고 세션 공유|
|**데이터 전송**|연결된 세션을 통해 JSON, 파일, 스트림 등 전송 가능|


##### Info.plist에 키들을 반드시 추가해줘야 하는 이유
**MPC통신**을 이용하기 위해서, `NSLocalNetworkUsageDescription`과 `NSBonjourServices`를 Info.plist에 **반드시** 추가해줘야 한다.

**Info.plist에 추가해줘야 하는 이유**
`Info.plist`파일은 IOS앱의 설정 정보를 담는 사전(Dictionary)형식의 파일이다.
이 파일은 앱이 실행되기 전에 IOS시스템이 읽어서, 앱이 어떤 권한을 요구하는지, 어떤 기능을 사용할 건지 등을 판단하는데 사용된다.


**MultipeerConnectivity**는 같은 네트워크에 있는 기기끼리 데이터를 주고받기 위해 로컬 네트워크에 접근해야 한다. 
`NSLocalNetworkUsageDescription`와 `NSBonjourServices`에 대해서 각각 알아보자.

`NSLocalNetworkUsageDescription`
- 사용자가 앱 처음 실행 시 **"이 앱이 로컬 네트워크에 접근하려 합니다"** 라는 알림을 보게 되는데
- 이때 **왜 접근이 필요한지 설명**을 `Info.plist`에 적어줘야 한다
- 시스템이 이 설명을 사용자에게 보여준다

`NSBonjourServices`
- MultipeerKit은 내부적으로 **Bonjour**라는 네트워크 서비스 탐색 기술을 사용한다
- Bonjour는 기기들 간 자동 인식에 쓰이는데,
- iOS는 **어떤 서비스 타입(_MKSVC._tcp 등)을 탐색할 건지 명시적으로 요구**한다

- IOS 14부터는 **보안과 개인정보 보호 강화**를 위해  
    시스템에 미리 알려진 권한 외에는 접근을 막는다.
    
- 위 키들을 추가하지 않으면, **Multipeer 연결 자체가 차단**되기 때문에  
    아무리 코드가 잘 짜여 있어도 상대방 기기를 찾을 수 없다.


##### 알림 팝업 띄울 때 최상위 뷰 컨트롤러를 찾아야 하는 이유
`MCNearbyServiceAdvertiserDelegate` 델리게이터를 구현할 때, 팝업을 띄워야 하는데
루트 뷰를 찾은 다음에 루트 뷰에서 최상위 뷰를 찾고 해당 최상위 뷰에 팝업을 띄운다.


##### (NextStep) 연결 자동으로 진행하기.

내가 구현한 방법에서는 요청을 통해서 광고자와 브라우저를 선정하는데, 자동으로 연결 하는 방법에서는 역할을 어떻게 배정할지 정하는 로직을 구현하는 것이 관건이다.

NameDrop는 MPC와 Nearby Interaction을 조합하여 사용된다.
Nearby Interaction은 근처에 기기가 어느정도 거리에 떨어져 있는지만 파악할 수 있고, 통신을 할 수는 없다.
그렇기 때문에 MPC를 통로로 사용하여 통신을 진행한다.


##### Custom SearchBar 구현

>예제) 검색 결과와 일치하는 목록 찾는 로직
```swift
var filteredItems: [String] {
	if searchText.isEmpty {
		return items
	} else {
	return items.filter {
		$0.lowercased().contains(searchText.lowercased()) }
	}
}
```

마지막 줄 `$0`의 의미는 **Swift의 클로저(Closure)** 안에서 **"현재 처리 중인 하나의 요소"** 를 의미한다.

```swift
items.filter { (item) in
    return item.lowercased().contains(searchText.lowercased())
}
```
위 코드에서 `item`을 생략해서 `$0`으로 쓴 것이다.

### 이슈
#### MCPeerID이름을 닉네임으로 설정하기
MCPeerID이름은 해당 기기를 의미하는 ID이므로 처음 설정된 
MCPeerID는 immutable 객체이기 때문에, 한 번 생성되면 displayName을 변경할 수 없다.
때문에 `restartWithNewNickname` 함수를 생성하여 MCPeerID를 직접 수정하는 것이 아니라,
기존의 모든 MultipeerConnectivity 관련 객체들(세션, 광고자, 브라우저)을 종료하고 새로운 MCPeerID로 완전히 새롭게 생성하는 방식을 사용.

단계별로 보자면,
1. 모든 현재 연결을 종료하고
2. 새로운 MCPeerID를 생성한 후
3. 새 MCPeerID로 전체 네트워킹 스택을 재구성.

**만일 닉네임이 같은 유저가 있다면 ?** 
- 기술적으로는 MultipeerConnectivity가 내부적으로 각 피어를 고유하게 식별하므로, 같은 이름을 가진 피어들도 시스템 내부에서는 구분된다.
- 하지만 사용자 인터페이스에서는 똑같아 보이므로 대상을 구분하기 힘듬.


이 접근법의 단점은 모든 활성 연결이 끊어진다는 것이지만, MCPeerID의 displayName을 변경하려면 이것이 유일한 방법이다.
이는 MultipeerConnectivity의 설계 제약사항이다.

공식 문서에 따르면, "기기의 피어 ID가 시간이 지나도 안정적으로 유지되도록 하려면 앱에서 광고나 탐색을 시작할 때마다 새 피어 ID를 생성하지 마세요. 대신, ID를 생성할 때 보관하고 다음에 필요할 때 보관을 해제하세요" 라고 나와있다. 때문에 `init(displayName: )`을 통해서 초기에 설정하기를 권장하고 있다.

>`초기에 실행될 때 부터 원하는 이름으로 설정하면 재시작 할 필요가 없지 없을까 ?`
> 해당 접근을 통한 구현방법을 더 찾아보기.

**가장 좋은 접근법?**
```swift
// 뷰가 생성되기 전에 이미 닉네임 정보를 알고 있다면
@StateObject private var sharingService: ProfileSharingService

init() {
    // SwiftData에서 닉네임 가져오기 (싱글톤 등을 통해)
    let nickname = /* 닉네임 가져오기 */
    _sharingService = StateObject(wrappedValue: ProfileSharingService(username: nickname))
}
```

> 접근 2. 디바이스의 ID를 변경해서 적용하기.

기기 자체의 deviceName을 변경해서 해당 닉네임을 전달하여 구현하기 ?


##### 공유 화면
방사형의 GUI가 꼭 필요할까 ?
유저들의 사용 흐름을 생각해보고 결정하기.
처음에 컨셉을 잡았으면 이런 고민을 할 필요가 없었을 것

#### peer별로 연결 상태 업데이트 하기

피어 개별 연결 상태를 반영하여 그리려고 하였는데,

`ForEach`문에서,
`let (icon, color) = connectionStateInfo(for: peerState)`
코드를 추가하면 `peer`를 `MCPeerID`타입이 아니라 `NSObject`타입으로 인식하여 `displayName`을 가져오지 못하는 현상이 발생함.

### 발표 내용
발표라기보다 일종의 **회고**라고 생각하자.

#### 프로젝트를 진행한 과정
- 아이디어 구상
- 필요한 기능 정리
- Lofi 그리기
- 무드보드 만들기
- Hifi 만들기
- 유저플로우 명확히 하기
- 필수 학습목표 체크

#### 진행하면서 발생한 문제

**QR코드에 JSON문자열을 담아서 보내면 이미지 포함이 안됨.**
배경 이미지를 제거하고, 프로필 이미지를 이모지로 변경.

**SwiftData 구조를 변경하니 데이터 저장이 안되는 현상**
코드를 샅샅이 뒤져보고 다시 수정을 해봐도 저장이 안됨.
에러가 발생하지도 않아서 원인을 못찾던 도중, 앱을 삭제했다 다시 설치하니 완료.
데이터 구조가 변경되면 따로 초기화를 진행해주거나, 삭제 후 설치를 통해 이전 데이터를 지워줘야 함.


#### 메인 타이틀(제목)
전체적인 컨셉을 타이틀에 녹이기.
발표의 구성은 스토리로 흘러가도록 구성.

시작 전에는 무언가를 한다고 착각했지만 완전히 하지 못하는 상태에 불과했다.

>기어다니기 -> 걸음마 -> 걷기
>울기 -> 옹알이하기 -> 말하기
>위 두 개의 매개체를 통해 발전해나가는 과정을 담기.

#### 걸음마가 뭐에요 ?

##### C2전 나의 상태
여기 능력이 뛰어난 사람들 사이에서, 내가 잘할 수 있는 것은 무엇일까 ?

C2를 진행하기 전에 나는 학습을 할 때 정보 습득을 위주로 진행하고 있었다.
하지만 기어다니는 아기가 넘어지지 않듯이 프로젝트를 진행하지 않으니, 실패를 통한 성장을 경험하기가 어려웠습니다.

그렇기 때문에 C2를 앞두고, 많은 시행착오를 겪으면서 성장을 경험하자!는 것이 저의 다짐이였습니다.

##### 나의 목표
**챌린지 관련된 나의 목표**
- 앱의 전체적인 UI를 직접 설계한다.
- 유저 플로우에 따라서 좋은 사용자 경험 설계하기
- 데이터를 로컬에 저장하는 방법 배우기

**나의 개인적인 목표**
- 아주 기본적인 앱을 A부터 Z까지 혼자서 완성해내기.
- 혼자의 힘으로 필요한 뷰 그리기
- 데이터 교환 방법 적용하기

##### 목표 지점
**App Statement**
각자의 핸드폰을 통해 도감 등록을 하여 러너의 정보를 수집하는 앱


**Feature List**
기능목록 첨부

#### C2를 거치며...
C2를 진행하면서 가장 크게 깨달았던 것은 한 걸을 내딛을 때마다 넘어지긴 해도 빠르게 나아가고 있다는 사실이였습니다.

평소 혼자 했던 방식으로는 몇 주에 걸쳐 나오게 될 결과물이 몇일만에 뚝딱 나오는 모습을 보면서,
점점 내가 만드는 앱에 정이 생기고, 재미가 붙기 시작했습니다.

##### 디자인 결과물 / 학습 내용

###### 디자인 결과물
피그마 디자인 공유

###### 학습 내용
초기에는 색상을 통해 분리감을 주도록 구성하였습니다.
그리고 한 러너에게 진심어린 피드백을 받게됩니다.
"잭 ! 색이 너무 많아서 눈이 썩을 것 같아요 ~!"

그 말을 듣고 디자인을 갈아 엎기로 결정했습니다.

세부적으로 디자인을 살펴보니, 가장 먼저 보이는 것이 색을 통해 분리감을 줬다지만 다른 부분에서 통일성이 없어서 어떤 부분에서 차이가 발생하는지 파악하기가 어려웠습니다.

때문에 나머지 부분은 통일하고 분류 기준인 분야에만 차이점을 주어 한 눈에 어디서 차이가 발생하는지 알아볼 수 있도록 변경하였습니다.

###### 학습 방법
사실 디자인 이론을 찾아보며 적용하기보다는, 잘 만들어진 앱들의 UI를 참고하여 적용했습니다.
레퍼런스를 수집하며 알게 된 사실은, 요즘 나오는 앱들은 색을 많이 사용하지 않고 대부분 정보 섹션을 배경과의 색상차이나 윤곽선을 주어 분리한다는 것을 알게 되었고, 앱에 적용하였습니다.

##### 코딩 결과물 / 학습 내용

###### 코딩 결과물

###### 학습 내용

**데이터 저장**
앱의 컨셉이 러너 도감이기 때문에, 데이터를 로컬에 저장하는 과정이 필수적이였습니다. 가장 간단하게 구현할 수 있어 Swift Data를 선택하고, Swift Data를 통해서 CRUD하는 방법을 익혔습니다.

**프로필 정보 전달**
처음에는 QR코드를 통해 데이터 전달을 하려고 했지만, QR코드를 촬영하는 과정이 번거롭다고 생각하여 근거리 통신으로 구현하기로 하였습니다.

처음에는 NameDrop처럼 박치기 형식으로 구현하려 했지만, 구현 방식이 까다로워 MultiPeer Connectivity방식만을 채택하여 근거리에서 데이터 교환을 구현하였습니다.

###### 학습 방법

학습 방법은 공식 문서를 먼저 살펴보고, 이해가 안되는 경우 구글 검색과 AI에게 물어보며 학습하였습니다. 


#### C2후, 나는

##### C2후 나의 상태

이전에는 공식문서를 볼 때 완전히 까막눈이였지만, 어떻게 읽어야 하는지 보는 방법을 터득했습니다.
이것이 C2를 진행하며 얻은 가장 큰 수확이라고 생각합니다.
어려운 기술이여도 천천히 차분하게 살펴본다면 결국 필요한 정보들을 다 담겨있고, 추가로 구글링이나 Ai를 통해 정보를 보완하는 형식으로 필요한 정보를 프로젝트에 적용할 수 있게 되었습니다.




#### 발표대본

#### 넘어지는 법 배우기
##### C2전 나의 상태
여기 능력이 뛰어난 사람들 사이에서, 내가 잘할 수 있는 것은 무엇일까 ?

C2를 진행하기 전에 나는 학습을 할 때 정보 습득을 위주로 진행하고 있었다.
하지만 기어다니는 아기가 넘어지지 않듯이 프로젝트를 진행하지 않으니, 실패를 통한 성장을 경험하기가 어려웠습니다.

그렇기 때문에 C2를 앞두고, 많은 시행착오를 겪으면서 성장을 경험하자!는 것이 저의 다짐이였습니다.

##### 나의 목표
설정한 목표는 다음과 같습니다.
이 중에서 가장 중요하게 생각하고 많은 시간을 투자한 부분은 기기 간 데이터 교환 적용하기였습니다.

##### 목표 지점
앱의 전체적인 컨셉은 러너 도감입니다.
그렇기 때문에 러너 간에 자신의 프로필을 서로 공유할 수 있는 기능이 필수적으로 필요했습니다.

#### C2를 거치며...
C2를 진행하면서 가장 크게 깨달았던 것은 한 걸을 내딛을 때마다 넘어지긴 해도빠르게 나아가고 있다는 사실이였습니다.

평소 혼자 했던 방식으로는 몇 주에 걸쳐 나오게 될 결과물이 몇일만에 뚝딱 나오는 모습을 보면서,
점점 내가 만드는 앱에 정이 생기고, 재미가 붙기 시작했습니다.

##### 디자인 결과물 / 학습 내용

###### 디자인 결과물
완성된 디자인은 다음과 같습니다.


###### 학습 내용
사실 초기 디자인은 지금과 달리 가독성이 매우 떨어졌습니다.
색상을 통해 분리감을 주고 싶었고, 때문에 많은 색상이 사용되는 결과로 이어졌습니다.
그리고 한 러너에게 진심어린 피드백을 받게됩니다.
"잭 ! 색이 너무 많아서 눈이 썩을 것 같아요 ~!"

그 말을 듣고 디자인을 갈아 엎기로 결정했습니다.

세부적으로 디자인을 살펴보니, 가장 먼저 보이는 것이 색을 통해 분리감을 줬다지만 다른 부분에서 통일성이 없어서 어떤 부분에서 차이가 발생하는지 파악하기가 어려웠습니다.

때문에 나머지 부분은 통일하고 분류 기준인 분야에만 차이점을 주어 한 눈에 어디서 차이가 발생하는지 알아볼 수 있도록 변경하였습니다.

###### 학습 방법
사실 디자인 이론을 찾아보며 적용하기보다는, 잘 만들어진 앱들의 UI를 참고하여 적용했습니다.
레퍼런스를 수집하며 알게 된 사실은, 요즘 나오는 앱들은 색을 많이 사용하지 않고 대부분 정보 섹션을 배경과의 색상차이나 윤곽선을 주어 분리한다는 것을 알게 되었고, 앱에 적용하였습니다.

##### 코딩 결과물 / 학습 내용

###### 코딩 결과물
시연 영상을 통해 결과물을 보여드리겠습니다.
프로필을 작성하고 공유에 들어가면, 각자 프로필에 등록한 닉네임으로 기기의 이름이 표시되고,
서로 기기를 연결하여 자신의 프로필을 전송할 수 있습니다.

공유 부분은 아직 디자인한 UI를 적용하지 못하여, 브릿지 기간동안 구현할 계획입니다.

###### 학습 내용

**데이터 저장**
앱의 컨셉이 러너 도감이기 때문에, 데이터를 로컬에 저장하는 과정이 필요하였고, 가장 간단하게 구현할 수 있는 방법인 Swift Data를 선택하고 Swift Data를 통해서 CRUD하는 방법을 익혔습니다.

**프로필 정보 전달**
처음에는 QR코드를 통해 데이터 전달을 하려고 했지만, QR코드를 촬영하는 과정이 번거롭다고 생각하여 근거리 통신으로 구현하기로 하였습니다.

처음에는 NameDrop처럼 박치기 형식으로 구현하려 했지만, 그냥 근거리에서 원격으로 데이터 교환을 할 수 있도록만 구현하였습니다.

###### 학습 방법

학습 방법은 공식 문서를 먼저 살펴보고, 이해가 안되는 경우 구글 검색과 AI에게 물어보며 학습하였습니다. 

#### C2후, 나는

##### C2후 나의 상태

이전에는 공식문서를 볼 때 완전히 까막눈이였지만, 어떻게 읽어야 하는지 보는 방법을 터득했습니다.
이것이 C2를 진행하며 얻은 가장 큰 수확이라고 생각합니다.
어려워 보이는 기술이더라도 천천히 차분하게 살펴본다면 결국 중요한 정보는 공식문서에 담겨 있고, 추가로 구글링이나 Ai를 통해 정보를 보완하는 형식으로 필요한 정보를 프로젝트에 적용할 수 있게 되었습니다.

하지만, 처음부터 정보만을 학습하며 프로젝트를 진행했더라면, 배우는 속도가 정말 더뎠을 것이라고 생각합니다.
때로는 무작정 밀고나가며 넘어지며 배우니 처음에 설정한 목표 또한 모두 달성한 것 같아 만족합니다.
특히 며칠동안 머리를 싸매고 고민하던 기능이 딱! 구현에 성공했을 때 그 뿌듯한 감정은 이루 말할 수 없는 것 같습니다.

이상으로 발표를 마치겠습니다. 감사합니다.

