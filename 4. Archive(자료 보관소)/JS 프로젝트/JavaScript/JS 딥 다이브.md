*JavaScript 실행*
JavaScript는 브라우저와 Node.js환경에서 실행할 수 있지만, 그 목적이 다르다. 브라우저에서는 Html,CSS,JS파일을 실행해 웹사이트에 표시하는 것이 목적이고, Node.js는 브라우저 외에서 JavaScript를 실행 할 환경을 제공하는 것이 주된 목적이다.

*변수*
변수를 사용하는 이유는, 컴퓨터는 임의의 메모리공간에 데이터를 임시로 저장하며 그 메모리 공간에 직접 접근하는 것은 매번 위치도 다르고 위험하므로 메모리 공간을 식별하기 위해 이름을 붙이는 것이 바로 **변수**.

*코드*
코드는 컴퓨터에게 내리는 명령임과 동시에 개발자를 위한 문서이기도 하다.

*ReferenceError :* 식별자(변수,함수,클래스 등)를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러.

*호이스팅*
자바스크립트는 소스코드가 순차적으로 실행되는 런타임 이전 단계에서 변수 선언이 먼저 진행된다. 이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 특징을 **변수 호이스팅**이라 한다.
(변수, 함수, 클래스 등 모든 식별자는 호이스팅된다.)

*자바스크립트의 네이밍 컨벤션*
변수, 함수 => 카멜 케이스
생성자 함수, 클래스 => 파스칼 케이스

*값 :* 표현식`(expression)`이 평가`(evaluate)`되어 생성된 결과
*리터럴 :* 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법. ex`(숫자는 123 문자는 abc 객체는 {} 배열은 [])`
*표현식`(expression)` :* 값으로 평가될 수 있는 문`(statement)` (식별자도 값으로 평가되므로 표현식이고 리터럴도 값으로 평가되므로 표현식)

*데이터 타입이 필요한 이유*
- 값을 저장할 때 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들여야 할 **메모리 공간의 크기**를 결정하기 위해
- 메모리에서 읽어 들인 **2진수를 어떻게 해석**할지 결정하기 위해

## 연산자
*비교 연산자*
`==` 는 값만 비교하고
`===`는 값과 타입까지 비교한다.
`===` 를 메인으로 사용하는 것이 좋지만 가끔 주의해야 할 부분이 있다.

NaN이나 0같은 경우 (+0과 -0을 같은 0으로 취급한다) 비교에 에러가 생기므로
Number.isNaN 함수나 Object.is메서드를 활용하자
```
-0 === +0           // -> true
Object.is(-0, +0)   // -> false

NaN === NaN         // -> false
Object.is(NaN, NaN) // -> true
Number.isNaN(NaN)   // -> true
```

*쉼표 연산자*
쉼표 연산자를 통해 변수 여러개를 한 번에 정의할 수 있으며, 마지막 값을 반환한다.
```
let x, y, z
x = 1, y = 2, z = 3 // 3
```

*삼항 연산자*
삼항 연산자는 if...else문을 대체할 수 있으며 if...else if문 또한 삼항 연산자를 이중으로 중복해서 사용해 표현할 수 있다.

삼항 연산자 표현식은 값처럼 사용할 수 있기 때문에 변수에 할당할 수 있다.
if else 문은 표현식이 아닌 문이므로 변수에 할당 불가.
```
const a = 1
let result = ''

// if문의 경우 블록 내의 문이 하나라면 중괄호를 생략할 수 있다.
if (a > 0)        result = "양수"
else if (a === 0) result = "영"
else (a < 0)      result = "음수" 

//삼항 연산자로 표현
result = a ? (a > 0 ? "양수" : "음수") : "영"
```

단순히 값을 결정하여 변수에 할당하는 경우라면, 삼항 조건 연산자를 사용하는 편이 **가독성이 좋다**.

*switch문*
주어진 표현식과 일치하는 표현식을 갖는 case문을 실행한다.
switch문은 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드를 결정할 때 사용.
```
//월을 영어로 변환. (11 -> 'November')
let month = 11
let monthName

switch (month) {
	case 1 : monthName = "January"
		break
	case 2 : monthName = "February"
		break
	case 3 : monthName = "March"
		break
	.
	. 
	// 중간 월 생략
	.
	.
	case 11 : monthName = "November"
		break
	case 12 : monthName = "December"
		break
	default : monthName = "Invalid month"
}

console.log(monthName) // November
```

일반적으로 if ... else문을 사용하는 것이 좋지만, 조건이 너무 많아서 switch 문을 사용했을 때 가독성이 더 좋을 경우 switch 문 사용.

## 타입 변환
자바스크립트에는 **명시적 타입 변환**과 **암묵적 타입 변환**이 존재한다.
명시적 타입 변환은 의도적으로 toString()등의 메서드를 사용해 타입을 변경하는 것이고, 암묵적 타입 변환은 자바스크립트가 자동적으로 타입을 변환하는 것이다.
암묵적 타입 변환은 개발자의 의도가 보이지 않아 혼란을 줄 수 있지만, 경우에 따라서 가독성이 더 좋게 사용될 수 있다.

### 암묵적 타입 변환
*문자열 타입으로 변환*
`"+"` 연산자의 경우 피연산자 중 하나 이상이 문자열이면 문자열로 변환한다.
```
1 + '2' // -> "12"
```

*숫자 타입으로 변환*
```
1 - '1'   // -> 0
1 * '10'  // -> 10
1 / 'one' // -> NaN
```
산술 연산자의 역할은 숫자 값을 만드는 것이므로, 숫자가 아닌 값을 숫자 타입으로 변환한다.

```
// 문자열 타입
+''               // -> 0
+'0'              // -> 0
+'1'              // -> 1
+'string'         // -> NaN

// 불리언 타입
+true             // -> 1
+false            // -> 0

// null 타입
+null             // -> 0

//underfined 타입
+underfined       // -> NaN

// 심벌 타입
+Symbol()         // -> TypeError : Cannot convert a Symbol value to a number

//객체 타입
+{}               // -> NaN
+[]               // -> 0
+[10, 20]         // -> NaN
+(function(){})   // -> NaN
```

빈 문자열, 빈 배열, null, false는 0으로, true는 1로 변환된다.

*불리언 타입으로 변환*
if문이나 for문과 같은 제어문 or 삼항 조건 연산자의 조건식은 불리언 값, 즉 참/거짓으로 평가되어야 하는 표현식이다. 자바스크립트는 조건식의 평가 결과를 불리언 타입으로 암묵적 변환한다.

- `false`
- `underfined`
- `null`
- `0, -0`
- `NaN`
- `''(빈 문자열)`
**위의 값들은 false로 평가되는 Falsy값**

이 외에 값들은 모두 true로 평가된다

## 단축 평가
**단축평가란 ?**
 - 표현식을 평가하는 도중에 결과가 확정된 경우 나머지 평가 과정을 생략하는 것.

*논리 연산자를 통한 단축평가*
```
'Cat' && 'Dog' // -> "Dog"
```
`&&` 은 결과를 결정하는 두 번째 피연산자 반환

```
'Cat' || 'Dog' // -> "Cat"
```
`||`는 결과를 결정한 첫 번째 연산자 반환

```
// map 객체에서 단축평가 사용 예시
const fruits = new Map()

fruits.set("apple", (map.get("apple") + 1) || 1)
```
해당 key가 존재하면 해당 키의 value에 1을 더해주고, 존재하지 않으면 false 이므로 true인 1이 초기값으로 들어간다. 

*옵셔널 체이닝 연산자*
옵셔널 체이닝 연산자 `?.`는 좌항이 null 또는 underfined인 경우 underfined를 반환하고, 그렇지 않으면 우항의 `프로퍼티 참조`를 이어간다.
`프로퍼티 참조란 ?`
변수이름을 통해 변수값을 참조하듯이, 객체의 key를 통해 value값을 참조.
```
const people = {
	name : "james"
}

let person = people?.name

console.log(person) // -> "james"
```


## Class
Class는 총 3가지의 메서드만을 정의할 수 있다.
- **constructor(생성자)**
- **프로토타입 메서드**
- **정적 메서드**

여기서 정적 메서드는 static을 통해 선언하며, 정적 메서드와 프로토타입 메서드의 차이는, 인스턴스를 통한 호출 가능 여부이다.

아래 예시를 통해 살펴보자
```
class Person {
	// 생성자
	constructor(name) {
		// 인스턴스 생성 및 초기화
		this.name = name
	}

	// 프로토타입 메서드
	sayHi() {
		console.log(`Hi, ${this.name} !`)
	}

	static sayHello() {
		console.log("Hello !")
	}
}

// me라는 인스턴스 생성
const people = new Person('Messi')
console.log(people.name) // 출력 : 'Messi'
me.sayHi() // 출력 : 'Hi, Messi !'
Person.sayHello() // 출력 : 'Hello !'
```
이처럼 프로토타입 메서드는 인스턴스를 통해 호출해야 하고,
정적 메서드는 인스턴스를 생성하지 않고 호출할 수 있는 메서드이다.

프로토 타입 메서드는 기존 생성자 함수를 통해 생성하는 경우 `prototype`에 메서드를 추가해야 했지만, 클래스에서는 암묵적으로 프로토타입 메서드가 된다.

```
// 기존 생성자 함수에서 프로토타입 메서드 정의
Person.prototype.sayHi = function () {
	console.log(`Hi! My name is ${this.name}`)
}

// 클래스 함수에서 프로토타입 메서드 정의
sayHi() {
	console.log(`Hi! My name is ${this.name}`)
}
```

결과적으로, 클래스는 생성자 함수와 마찬가지로 프로토타입 기반의 객체 생성 메커니즘을 알 수 있다.

또한, 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있는 반면에
정적 메서드는 인스턴스 프로퍼티를 참조할 수 없다.
쉽게 말하면, 정적 메서드에서는 constructor를 통해 생성한 인스턴스를 참조 불가능하다.

때문에 정적 메서드는 인스턴스를 참조하지 않는 전역 함수 느낌이라 생각하면 된다. 이를 메서드로 구조화 시킬 뿐. (ex. Math.max(1, 10))