
# 진수
## 진수의 종류와 개념

진수란 숫자를 표현하는 방식 중 하나로, **기수법(radix system)** 이라고도 한다.
어떤 진수냐에 따라 사용하는 숫자의 범위와 자리값이 달라짐.

### 1. **2진수(Binary, 기수: 2)**

- **사용 숫자:** 0, 1
- **자릿값:** 2의 거듭제곱
- **사용 예:** 컴퓨터 내부에서 사용하는 기본 진법
- **예:** `1011₂` = 1×2³ + 0×2² + 1×2¹ + 1×2⁰ = **11₁₀**

### 2. **8진수(Octal, 기수: 8)**

- **사용 숫자:** 0 ~ 7
- **자릿값:** 8의 거듭제곱
- **사용 예:** 3비트를 1자리로 표현 → 2진수를 간결하게 나타낼 때 사용
- **예:** `17₈` = 1×8¹ + 7×8⁰ = **15₁₀**

### 3. **10진수(Decimal, 기수: 10)**

- **사용 숫자:** 0 ~ 9
- **자릿값:** 10의 거듭제곱
- **사용 예:** 우리가 일상적으로 사용하는 진법
- **예:** `325₁₀` = 3×10² + 2×10¹ + 5×10⁰

### 4. **16진수(Hexadecimal, 기수: 16)**

- **사용 숫자:** 0~9, A(10), B(11), C(12), D(13), E(14), F(15)
- **자릿값:** 16의 거듭제곱
- **사용 예:** 4비트를 1자리로 표현 → 2진수를 더 간결하게 나타낼 때 사용
- **예:** `1A₁₆` = 1×16¹ + 10×16⁰ = **26₁₀**

---

### 🧠 실기 시험 대비 핵심 포인트

- 진법 변환(2진수 ↔ 10진수, 2진수 ↔ 8진수, 2진수 ↔ 16진수)
- 비트와 바이트 단위 변환
- 2진수의 보수 계산(1의보수, 2의 보수)
- 정수/실수의 이진 표현 방식


## C언어

### 포인터
>C언어에서 포인터는 **메모리 주소를 저장하는 변수**를 의미한다. 
>즉, 일반 변수는 값을 저장하지만, 포인터는 **값이 저장된 메모리의 위치(주소)를 저장**한다.

**각 요소의 의미**
- `a`: 정수형 변수, 값은 `10`
- `&a`: 변수 `a`의 주소값
- `p`: `int`형 포인터 변수
- `*p`: 포인터 `p`가 가리키는 주소의 값 (즉, `a`) 

#### 포인터의 선언
```
int *p;     // int형을 가리키는 포인터
float *fp;  // float형을 가리키는 포인터
char *cp;   // char형을 가리키는 포인터
```
> 자료형과 일치하는 포인터를 사용해야 한다.

---

#### 포인터의 주요 연산

|연산|설명|예시|
|---|---|---|
|`&`|주소 연산자|`&a`는 변수 `a`의 주소|
|`*`|간접 참조 (역참조) 연산자|`*p`는 `p`가 가리키는 주소의 값|
|`p + 1`|다음 요소의 주소 (자료형 크기만큼 이동)|`int *p`라면 `p+1`은 4바이트 뒤 주소|

---

#### 예제 코드

```
#include <stdio.h>

int main() {
    int a = 10;
    int *p = &a;

    printf("a의 주소: %p\n", &a);
    printf("p의 값 (a의 주소): %p\n", p);
    printf("*p의 값 (a의 값): %d\n", *p);

    return 0;
```

---

#### 포인터의 활용

1. **함수에서 값 변경**
  
	- 포인터를 통해 인자의 실제 값을 바꿀 수 있다.
```
void change(int *p) {
    *p = 100;
}

int main() {
    int a = 10;
    change(&a);
    printf("%d\n", a);  // 출력: 100
}
```

2. **배열과 포인터**
    
    - 배열 이름은 곧 첫 번째 요소의 주소이므로 포인터처럼 사용 가능하다.
```
int arr[3] = {1, 2, 3};
int *p = arr;

printf("%d\n", *(p + 1));  // 출력: 2
```
3. **문자열 처리**
    
    - 문자열 리터럴은 `char *` 포인터로 다룬다.
```
char *str = "Hello";
printf("%c\n", *(str + 1));  // 출력: e
```


### 널 문자
>C 언어에서 문자열의 끝은 **`'\0'`** (널 문자)로 표시함.
>문자열은 단순히 문자 배열이지만, 끝을 알 수 있게 **마지막에 `'\0'`을 자동으로 붙여준다.**



---
## Java언어

### 생성자
> 클래스 이름과 동일한 이름을 가진 **특별한 메서드**

**특징**
- 반환형이 없다(void 조차 쓰지 않음).
- 객체가 생성될 때 딱 한 번 자동으로 호출된다.
- 주로 멤버 변수 초기화 같은 작업을 한다.

**예**
``` java
public cond(int v) {
	value = v;
}
```

### 추상 클래스와 형 변환의 개요
**추상 메소드**
>자식 클래스에서 재정의해야만 사용할 수 있는 메소드

**추상 클래스**
>추상 메소드를 하나 이상 포함하는 클래스

**클래스의 형 변환**
>부모 클래스의 객체 변수를 선언할 때 자식 클래스의 생성자를 이용하면,
>부모 클래스의 객체 변수를 통해 추상 메소드를 사용할 수 있다.


### 메서드

#### `.equals()`와 `==`의 차이

`==` → **참조값(주소)** 비교 (같은 객체인가?)
`.equals()` **->** **내용(값)** 비교(같은 내용인가 ?)

문자열 같은 경우에는 무조건 `.equals()`를 사용해야 정확한 값 비교가 된다.

### 출력

**출력 메서드 종류**

| 메서드                    | 설명                                       |
| ---------------------- | ---------------------------------------- |
| `System.out.print()`   | 줄바꿈 없이 출력                                |
| `System.out.println()` | 출력 후 **자동으로 줄바꿈**                        |
| `System.out.printf()`  | **형식을 지정(format)**해서 출력 (C언어 `printf`처럼) |

**출력 형식**
`System.out.printf("%d, %d\n", i, j)`
**Java**는 `""` 쌍따옴표 사이에 출력 형식에 맞춰 출력이 된다.

따라서 `%d`와 `%d\n`사이에 **콤마**`,`가 있으므로, 출력할 때 두 개의 요소 사이에 콤마를 붙여서 출력한다.


### 제네릭(generic)
> "자료형(type)을 나중에 정할 수 있게 미리 비워두는 틀"
- 클래스, 인터페이스, 메서드를 정의할 때 타입을 일반화해서 코드 재사용성을 높이고, 타입 안정성을 보장해준다.

#### 제네릭은 왜 사용할까 ?

**먼저, 제네릭을 사용하지 않는 경우를 먼저 살펴보자.**

예를 들어 `박스(Box)`라는 클래스가 있고, 여기에 뭔가 값을 담고 싶다.
```java
public class Box {
    private Object item;

    public void set(Object item) {
        this.item = item;
    }

    public Object get() {
        return item;
    }
}
```
사용할 땐:
```java
Box box = new Box();
box.set("Hello");
String s = (String) box.get();  // (String) 형변환 필요
```
**문제점:**
- `Object`는 아무거나 다 넣을 수 있어서, 잘못된 타입도 들어감.
- 꺼낼 때 무조건 **형변환**해야 해서 불편하고, 실수로 잘못 형변환하면 프로그램이 터질 수도 있다.

#### 제네릭을 쓰는 경우

이제 `Box`를 제네릭으로 바꿔보자.

```java
public class Box<T> {
    private T item;

    public void set(T item) {
        this.item = item;
    }

    public T get() {
        return item;
    }
}
```
여기서 `<T>`는 **타입을 나중에 정하겠다는 뜻**.
박스를 쓸 때 어떤 타입으로 쓸지 결정할 수 있다.

---

###  제네릭 박스 사용 예

```java
Box<String> stringBox = new Box<>();
stringBox.set("Hello");
String s = stringBox.get();  // 형변환 필요 없음!
```

```java
Box<Integer> intBox = new Box<>();
intBox.set(123);
Integer i = intBox.get();
```


---
## Python언어

### boolean타입
언어별로 `boolean`타입 표기를 **대문자**로 하는 언어는 **Python**밖에 없다.


## SQL - DDL

### DDL(Data Define Language, 데이터 정의어)
#### 전체 연관 구조 정리
```css
[SCHEMA]
 └── [TABLE] ← [DOMAIN] 사용 가능
       └── [INDEX] 적용 가능
       └── [VIEW]는 테이블을 참조하여 정의됨
```

|요소|역할|예시 관계|
|---|---|---|
|SCHEMA|모든 객체를 담는 공간 (최상위)|테이블, 뷰, 인덱스가 스키마 안에 포함됨|
|DOMAIN|컬럼의 데이터 형식 및 제약조건 정의|테이블의 컬럼에서 사용됨|
|TABLE|데이터를 저장하는 구조체|뷰와 인덱스가 이 테이블 기반으로 생성됨|
|VIEW|테이블을 참조하는 가상 테이블|SELECT 쿼리 결과를 테이블처럼 보여줌|
|INDEX|테이블 검색 성능을 향상시키는 도구|테이블 컬럼에 대해 생성됨|


### 키 개념
#### ✅ 1. 기본키 (Primary Key)

- **각 행(row)을 유일하게 식별할 수 있는 키**야.
    
- **중복되면 안 되고(NULL도 안 돼)**, 테이블에서 반드시 **하나만 존재**해야 해.

``` sql
CREATE TABLE student (
	student_id INT PRIMARY KEY,  -- 기본키
	name VARCHAR(50),
	age INT
);
```
📌 예: `주민등록번호`, `학번`, `제품코드` 등  
→ **절대 겹치지 않는 식별자**를 기본키로 설정해.

---

#### ✅ 2. 대체키 (Alternate Key)

- **기본키 후보들 중에서 선택되지 않은 나머지 키**야.
    
- 즉, 기본키가 될 수 있었지만 **선택받지 못한 키들**이야.

``` sql
-- 예시
학번 (기본키 후보)
주민등록번호 (기본키 후보)

→ 학번을 기본키로 선택하면, 주민등록번호는 **대체키**
```

📌 의미: 기본키처럼 **유일성은 있지만**, 실제로 기본키로 **채택되지 않은 키**를 말해.

---

#### ✅ 3. 외래키 (Foreign Key)

- **다른 테이블의 기본키를 참조하는 키**야.
    
- 두 테이블을 **연결(관계)**할 때 사용해.

``` sql
CREATE TABLE course (
	course_id INT PRIMARY KEY,
	course_name VARCHAR(50),
	student_id INT,
	FOREIGN KEY (student_id) REFERENCES student(student_id)
);
```

📌 설명: `course` 테이블에서 `student_id`는 `student` 테이블의 `student_id`를 참조함 → 외래키!

→ 외래키는 **참조 무결성(Integrity)**을 지켜주는 역할을 해.

---

#### 📌 세 가지 키 정리 표

|키 종류|설명|특징|
|---|---|---|
|기본키(PK)|각 행을 유일하게 식별하는 키|중복 ❌, NULL ❌, 1개만 가능|
|대체키(AK)|기본키 후보 중, 선택되지 않은 키|중복 ❌, NULL ❌|
|외래키(FK)|다른 테이블의 기본키를 참조하는 키|중복 ⭕, NULL ⭕ (제약에 따라 다름)|

---

#### 🔄 관계 예시
``` text
[학생 테이블]
학번(PK), 이름, 주민등록번호(AK)

[수강 테이블]
수강번호(PK), 강의명, 학번(FK)
```

- **학번**은 `학생 테이블`에서 기본키(PK)
    
- **주민등록번호**는 대체키(AK)
    
- `수강 테이블`에서 학번은 외래키(FK)


## DML - SELECT - 2
SELECT문에서 실행 순서는 아래와 같다.

1. FROM
2. WHERE
3. GROUP BY
4. HAVING
5. SELECT
6. ORDER BY

**1. FROM**
데이터를 가져올 테이블을 선택한다.
`전체 행 컬럼이 다 있는 상태`

**2. WHERE**
행 하나하나를 검사해서 가져올 행들을 필터링한다.
`그룹을 만들기 전의 개별 행 필터`

**3. GROUP BY**
남은 행들을 그룹별로 묶는다.
`하나의 속성에 따라서 행들을 그룹으로 묶어둔다`

**4. HAVING**
그룹 바이 절에서 만든 그룹에서 해당 그룹의 조건을 검사한다.
`그룹에 대한 조건 검사`

**5. SELECT**
조건을 통과한 그룹에서 가져올 데이터를 출력한다.


#### 상여금 예시
##### ① `FROM 상여금`

- `상여금`이라는 테이블에서 데이터를 가져와.
    
- 이 시점에는 **전체 행 전체 컬럼이 다 있는 상태**야.
    

---

##### ② `WHERE 상여금 >= 100`

- **행 하나하나를 검사해서**, `상여금` 값이 **100 이상인 행만 남겨**.
    
- **그룹을 만들기 전에 먼저 필터링**을 하는 단계야.
    

🧠 `WHERE`은 **그룹을 만들기 전의 개별 행 필터**라고 꼭 기억해!

---

##### ③ `GROUP BY 부서`

- 이제 남은 행들을 **부서별로 묶어**.
    
- 즉, 부서가 같은 행들끼리 **그룹(묶음)**을 만든다.
    

예:

```makefile
부서: 영업
 → 사람 1, 사람 2, 사람 3

부서: 총무
 → 사람 4, 사람 5
```

---

##### ④ `HAVING COUNT(*) >= 2`

- 위에서 만든 그룹(부서별 묶음) 중에서,  
    **해당 그룹의 조건을 검사해**.
    
- 여기서는 `COUNT(*) >= 2`,  
    즉, **해당 부서에 2명 이상이 상여금 100 이상을 받았는지** 검사.
    

🧠 `HAVING`은 **그룹에 대한 조건**이야.  
`WHERE`과는 다르게, **그룹 함수(COUNT, SUM 등)를 쓸 수 있어**.

---

##### ⑤ `SELECT 부서, COUNT(*) AS 사원수`

- 이제 조건을 통과한 그룹들에서  
    `부서` 이름과 `COUNT(*)` 값을 출력해.
    
- `COUNT(*)`는 해당 그룹(부서) 안에 **조건을 통과한 행의 개수**야.
    
- `AS 사원수` → 결과 컬럼 이름을 **'사원수'**라고 표시해줘.
####

### JOIN

#### 요약표 (정리용)

|JOIN 종류|키워드/구조|특징|
|---|---|---|
|INNER JOIN|`INNER JOIN ... ON`|공통 행만|
|LEFT JOIN|`LEFT JOIN ... ON`|왼쪽 모두 + 매칭|
|RIGHT JOIN|`RIGHT JOIN ... ON`|오른쪽 모두 + 매칭|
|FULL JOIN|`FULL OUTER JOIN ... ON`|양쪽 모두|
|CROSS JOIN|`CROSS JOIN`|곱집합|
|SELF JOIN|자기 자신과 조인|자기 비교|
|NATURAL JOIN|`NATURAL JOIN`|자동 연결|
|EQUI JOIN|`WHERE A.x = B.x`|`=` 조건 조인|
|NON-EQUI JOIN|`WHERE A.x < B.x` 등|범위 조건 조인|


## 인터넷
> 인터넷이란 ? **TCP/IP 프로토콜**을 기반으로 **전 세계 수많은 컴퓨터와 네트워크들이 연결된 광범위한 컴퓨터 통신망**

### TCP/IP 프로토콜이란 ?
컴퓨터끼리 **인터넷에서 데이터를 주고받기 위한 프로토콜**이며 크게 **4계층**구조로 이루어져 있다.

|계층|역할|주요 프로토콜|
|---|---|---|
|**응용 계층**|사용자 앱 간의 통신|HTTP, FTP, SMTP 등|
|**전송 계층**|앱 간 데이터 전달 보장|**TCP**, **UDP**|
|**인터넷 계층**|컴퓨터 간 주소 지정 및 경로 설정|**IP**, ARP, ICMP|
|**네트워크 인터페이스 계층**|실제 물리적인 데이터 전송|이더넷, Wi-Fi 등|

**웹페이지를 여는 예시를 통해 살펴보자**
1. 크롬에서 주소 입력 → **HTTP 요청 발생 (응용 계층)**
2. 데이터를 **TCP**가 쪼개고 순서 정함 (전송 계층)
3. **IP**가 목적지 주소 붙임 (인터넷 계층)
4. 실제 신호가 케이블이나 와이파이 통해 전송됨 (인터페이스 계층)



### 그래서 IP가 뭐야 ?
> 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소

- 8비트(1바이트)씩, 총 32비트로 구성되어 있다.
- IP주소는 네트워크 부분의 길이에 따라 다음과 같이 A 클래스에서 E 클래스까지 총 5단계로 구성되어 있다.

**네트워크 주소**
> 이 IP가 **어느 네트워크(동네, 회사)** 에 속해 있는지 나타냄

**호스트 주소**
> 해당 네트워크 안에서 **어떤 장비(PC, 프린터 등)**인지 나타냄

**IP 주소** = 네트워크 주소 + 호스트 주소

**브로드 캐스트 주소**
> **하나의 네트워크 안에 있는 모든 장비(호스트)에게 한꺼번에 메시지를 보내는 주소**.

브로드캐스트 주소가   `192.168.0.255`와 같다면,
- `255`는 해당 네트워크의 **호스트 주소 영역에서 가장 큰 값**
- **이 주소로 보내면 네트워크에 있는 모든 장비가 받는다**

### 서브네팅
> 하나의 IP 네트워크를 **여러 개의 작은 네트워크(서브넷)**로 나누는 기술  
> 네트워크 자원을 **효율적으로 관리**하고, **브로드캐스트 범위**를 줄일 수 있음

- 기존의 네트워크 주소에서 **호스트 비트를 일부 빌려** 서브넷 구분자로 사용
- 결과적으로 **서브넷 개수는 늘고**, **각 서브넷의 호스트 수는 줄어듦**

#### 서브넷 마스크
> IP 주소에서 **네트워크 주소와 호스트 주소를 구분**하기 위한 32비트 값을 **서브넷 마스크**라고 하며, 이를 변경하여 네트워크 주소를 여러 개로 분할하여 사용한다.

- **1은 네트워크**, **0은 호스트**
- 예: `255.255.255.0` = `11111111.11111111.11111111.00000000`

#### 서브네팅 예시
**예제**
- IP: `192.168.1.0/24` (기본 C클래스)
- 서브네팅 목표: 각 서브넷에 **최대 30대 장비**

**풀이**
1. 필요한 호스트 수: 30 + 2(네트워크 & 브로드캐스트) = 32
    
2. `2^5 = 32` → 호스트 비트 5개 필요 → 네트워크 비트 27개
    
3. 결과: `/27` 서브넷 마스크 = `255.255.255.224`
