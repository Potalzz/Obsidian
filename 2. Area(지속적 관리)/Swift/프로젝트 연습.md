## movie api projet

**개념**
- [x] urlsession 
- [ ] dispatchqueue
- [ ] swiftUI stack

**학습방식**
일단 클론코딩을 하든 완성을 한 다음 요소들을 살펴보면서 어떻게 작동하는지 구글에 검색

## 아이폰 계산기 앱
아이폰 계산기 앱 따라서 만들어보기
자리수마다 콤마넣는건 기능 모두 구현하고 마지막에 추가하기.

이전 연산자 기억해서 새로운 연산자 추가되면 이전 연산자로 값 계산하는 과정 넣고, equal버튼 눌리면 모든 기억 값 초기화되게 구현하기.

### 기능 구현
숫자를 누르면 tempNum에 수가 하나씩 추가되고 연산자를 누르면 tempNum인 수가 formula에 추가되는 형식.
연산자는 따로 연산자 모음 배열에 저장해준다.

**결과값이 나온 상태에서 숫자 버튼을 누르면 새로운 수가 입력되고, 연산자 버튼을 누르면 연산을 이어서 지속하는 기능 구현.**
- 결과값은 result변수에 저장해서 if else문으로 띄울 텍스트 정하기


**수식 넣기**
Array에 요소를 하나씩 추가한다.

**자릿수에 따른 콤마 넣기**
- 자릿수를 체크하는 변수인 digitCheck를 만든다.
- 숫자버튼이 눌릴 때마다 digitCheck +=1을 해준다.
- 3을 넘기게 되면 lastIndex - 3 위치에 콤마를 먼저 추가한 뒤 숫자를 추가한다.
- 연산자 버튼이 눌리거나 4가 된 경우 0으로 초기화
- . 버튼이 눌리는 경우 -50으로 초기화 (소수점에는 콤마가 필요없으므로)




### 마주친 문제
#### for 루프 사용 불가
계산기 아이콘을 하드코딩하여 표신하는 대신 for루프로 구현하러 했으나 swiftUI의 body 내부에서는 for 루프가 사용이 불가

**해결 방안**
ForEach struct를 사용하여 구현.

```
ForEach(self.buttons[0], id: \.self) { button in
	Text(butotn)
}
```

ForEach는 각 데이터마다 고유 식별자(id)가 필수로 있어야 한다.
`self.buttons[0]`는 정수 배열이므로, `id: \.self`를 사용하면 각 정수를 그대로 식별자로 사용한다.



### 리팩토링
MVVM으로 구성.
Model에서 연산자들은 enum으로 구성해준다


### 리이오 강의

**색상 가져오는 방법**
	Assets에서 Color Set만들고, Inspector에서 컬러피커로 색상 가져와서 만들기.
	불러올 때는 `Color(String)`형태로 만들어둔 에셋 이름을 넣어서 가져오기.
	


## 스톱워치

#### 기능 목록

**시간 측정**
- [ ] 시작 버튼을 클릭하면 화면상 시간이 흘러간다.
- [ ] 중단 버튼을 누르면 시간이 중지된다.

**시간 기록**
- [ ] 랩 버튼을 누르면 labTime을 0으로 초기화한다.
- [ ] 랩 버튼을 누르면 이전 labTime으로부터 경과된 시간을 랩`(N)`으로 화면에 출력한다.

**시간 초기화**
- [ ] 재설정 버튼을 누르면 모든 기록이 초기화된다.


시작 버튼 누르면, 총 시간이랑 랩타임 시간이 동시에 흘러감.
랩 버튼 누르면 랩타임 시간을 화면에 출력하고 시간 초기화함.

timeInterval은 typealias로 이름만 바꾼 Double 타입이다.



## Todo List

#### 기능 목록

**할 일 등록하기**
- [ ] 우측 상단 + 버튼을 눌러 할 일 등록 목록을 띄운다
- [ ] 목표, 시간을 입력하여 할 일을 등록한다.
- [ ] 등록된 할 일은 목록에 표시된다.

**할 일 들어가기**
- [ ] 할 일을 클릭하여 상세 페이지로 넘어간다.
- [ ] 목표와 시간이 나와있고, 완료 버튼을 눌러 완료할 수 있다.




### 에러
```


var datas = (0...100).map(String.init).map(SomeData.init)

var datas: [SomeData] {
	dataNums.map(String.init).map(SomeData.init)
}



struct SomeData: Identifiable {

    var name: String
    var id: String { self.name }
}
```

`datas`에 `(0...100)`대신 배열을 넣으니 **인스턴스 속성을 다른 속성(sum)의 초기화 중 사용 불가합니다** 라는 오류가 발생.

에러가 발생하는 이유는 **Swift**에서는 속성 초기화 순서가 중요한데, 모든 속성을 초기화할 때 다른 속성을 참조할 수 없다.

`dataNums`를 이용해 `datas`를 초기화하려고 하는데, **`dataNums`가 초기화되기 전에 `datas`가 초기화되려고 하므로 오류가 발생한다.**

==**해결 방법**==
`datas`를 계산 속성으로 바꾸면 해결된다 !
계산 속성을 `get`을 호출할 때마다 실행되므로, 속성 초기화 순서 문제를 피할 수 있다.

```
var datas: [SomeData] {
	dataNums.map(String.init).map(SomeData.init)
}
```
위 코드의 `datas`는 저장 속성이 아닌 계산 속성으로 값을 저장하지 않고, 호출될 때마다 실행되는 함수 같은 속성이다.
JS의 Const함수와 비슷한 개념이지만 약간 다른 점은, Js의 Const함수는 함수가 호출될 때 실행되는 반면 계산 속성은 속성이 접근될 때 실행된다.
