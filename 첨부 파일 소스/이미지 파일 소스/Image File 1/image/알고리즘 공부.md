## ==예제 모음==

### 피보나치 수열 계산 (참고 완)
![[Screenshot_20230927_164421_YouTube.jpg]]
![[Screenshot_20230926_234537_YouTube.jpg]]
-풀이-
![[Pasted image 20230928185210.png]]
그냥 반복문으로 두개를 더해주면 됨.
기본적인 원리에 충실하면 된다. 해당 수에 이전 수를 더해주는 걸 n번만큼 하기


### 행렬 곱
![[Screenshot_20230927_164347_YouTube.jpg]]

### binary search

### 숫자 정렬하기




## ==**팁**==
슬라이싱은 리스트뿐만 아니라 일반 문자열에도 사용 가능.

**예외처리 방법**
![[Pasted image 20231006235825.png]]
try, except

**문자열 리스트로 만들기**
s = "AB" 인 경우에
s = s.split을 사용하면 ["AB"]가 된다.
하지만 
s = list(s)를 사용할 경우 ["A","B"]가 된다.

ZeroDivision Error
숫자를 0으로 나누면 에러가 발생
## ==**함수**==

==zip 함수==
![[Pasted image 20230928232859.png]]
===spit 함수==
![[Pasted image 20231004222631.png]]
string = "Hello World Python"
string.split( )
-> ["Hello", "World", "Python"]

==join 함수==
**리스트에 있는 함수를 하나의 문자열로 합쳐주는 함수**

사용 방법
- " ".join(리스트)
- " " 따옴표 사이에 넣은 문자를 값 사이에 넣어줌

사용 예시
- my_list = ["Hello", "World", "Python"]
- "."join(my_list)
- -> Hello.Wolrd.Python

==map 함수==
**여러 인자를 가진 자료형을 받아, 각 요소마다 함수를 적용해 반환.**

사용 방법
- map(적용시킬 함수, 적용시킬 값들)
- map( 값에 +1 을 더해주는 함수, [1,2,3,4,5]) 
	함수의 반환을 list(. )로 감싸주면  
	**[2,3,4,5,6]** 이 되는 함수.

사용 예시 1 (함수 적용시키기)
- my_list = [1,2,3,4,5]
- def add_one(n):
	 return n + 1
- list(map(add_one, my_list))
- -> [2,3,4,5,6]

사용 예시 2 (type 변환하기)
- my_num = 12345
- list(map(int, my_num))
- -> [1,2,3,4,5]

==문자열 숫자열 판별==
문자열.isalpha ( ) 알파벳이면 True,False 반환
문자열.isdigit ( ) 숫자면 True,False 반환

isupper,islower 은 대,소문자 판별하는 거고
upper,lower 가 대 소문자로 변경해주는거

==아스키 코드 변환 함수==
**ord ( )**
- 문자를 아스키 코드로 바꿔줌
- ord("a") -> 97

**chr ( )**
- 아스키 코드를 문자로 바꿔줌
- chr(97) -> "a"

==sort( ) 와 sorted( )==
**sort ( )**
- 리스트만 정렬 가능
- s.sort( ) 로 사용
- 기존의 리스트를 정렬하고 변환

**sorted ( )**
- sorted (s, key값 또는 reverse = True 사용 가능)
- 기존의 리스트를 정렬하고 새로운 리스트를 반환함
- Key를 통해서 정렬 기준을 세울 수 있다.
 ->리스트안에 있는 문자의 2번째 알파벳을 통해 정렬하고 싶다면
	 sorted(s, key = x : x[2]) 

==진수 변환==
**진수와 진법이란?**
- 진법: 2진법,3진법,10진법 등등
- 진수: 숫자를 해당 진법으로 계속 나눴을 때 마지막 몫과 나머지를 나열한 수
- 2진법 변환 예시
![[Pasted image 20231009171931.png]]

**n진수 -> 10진수**
- int("숫자",진수)![[Pasted image 20231009170857.png]]

**10진수 -> 2, 8, 16진수**
- 2진수 -> bin(11) = 0b1011
- 8진수 -> oct(11) = 0o13
- 16진수 -> hex(11) = 0xb
- 반대로 바꿔주려면 앞에 알파벳을 입력하면 됨.

**10진수 -> n진수**
- 따로 함수가 없는 경우에는 코드를 사용해야 한다.
- def solution(n,q):
	  rev_base = ' '
	 while n> 0:
		 n, mod = n//q, n%q  <- (divmod 함수를 쓰면 divmod(n, q)로 표현 가능)
		 rev_base += str(mod)
	 return rev_base[::1] (역순으로 뒤집어 줘야 변환하고자 하는 수 출력됨)

==dictinary==
변수 이름 = dict ( ) 를 통해서 빈 딕셔너리 생성 가능

==zfill==
문자열.zfill(n)
- 스트링 앞에 0을 채워 넣어줘서 n개의 길이로 바꿔줌.
- ex) 'abc' 를 길이 5로 만들면 '00abc'

## ==문제==


### 달리기 경주 문제 (참고 완)

![[Pasted image 20230929003219.png]]
이렇게 풀었더니 시간 복잡도에서 걸렸다.
for문 안에서 index를 계속 호출해서 그런듯

그래서 찾아본 결과 enumerate( )함수를 사용하면 해결 가능.

enumerate( )가 무엇인가 ?
-  인덱스와 원소로 이루어진 tuple을 만들어줌 
- 인덱스 값을 포함하기 때문에 순서가 필요한 경우에 자주 사용
사용 방법
- for 문의 in뒷 부분을 enumerate(array) 형태로 감싸주면 됨![[Pasted image 20230929003722.png]]
- 시작 인덱스 변경도 가능  ![[Pasted image 20230929004056.png]]

![[Pasted image 20230929010508.png]]
문제풀이 결과

처음에 사전을 만들어주고 enumerate함수를 통해 idx에 위치, player에 선수이름을 배정해준 뒤, 키값에 선수 이름을 넣고 벨류값에 위치를 넣는다.

for문을 통해 선수의 위치를 사전에서 불러내주고, location에 선수의 위치를 저장한다.

swap을 통해 players의 순서를 바꿔줌


players 순서만 바뀌고 사전에 순서는 안바뀌었으니, 다음 순서변경을 위해서 사전을 업데이트 해준다.

![[Pasted image 20230929012351.png]]
사전 업데이트 코드는 이렇게 짜는게 더 이해하기 쉬운듯
### 완주하지 못한 선수 (공부해서 다시풀기)
![[Pasted image 20230929021225.png]]
풀면서 Hash 구조 익히기

### 유튜브 - 이진탐색 떡 자르기

**문제**
![[Pasted image 20231008202155.png]]

**정답 코드**
![[Pasted image 20231008202244.png]]
하나씩 차근차근 계산하면 됨.



### 같은 숫자는 싫어(완)

**문제**
![[Pasted image 20231004192755.png]]

**나의 풀이**
![[Pasted image 20231004192916.png]]

**효율적인 풀이**
![[Pasted image 20231004193032.png]]

==배운 점==
내 풀이는 시간 복잡도에서 효율이 떨어졌음.
그 이유는 arr배열의 인덱스를 계속해서 계산했기 때문.

효율적인 풀이는 스택 알고리즘을 통해 가장 마지막에 들어온 문자와만 비교해서 다를 경우 바로 i를 추가해줘서 인덱스 찾을 일이 훨씬 적다.

어떠한 조건에서 i를 추가하면 될 지 조건을 따져보자.
나는 arr배열에서 어떻하면 알맞게 "꺼내올"조건을 생각했는데 
차례대로 꺼내고 알맞게 "집어넣을"생각은 못했다.
### 크기가 작은 부분문자열(완)

**문제**
![[Pasted image 20231004232424.png]]

**나의 풀이**

- 첫번째 풀이
![[Pasted image 20231004232501.png]]

- 두번째 풀이
![[Pasted image 20231005211201.png]]

==배운 점==
- 굳이 길이가 1일 경우는 추가할 필요 없다.
-  풀이 방식은 똑같은데 첫 번째 풀이에는 int로 감싸지 않아서 정수끼리 크기를 비교하게 되어 오류가 났다.
- [0:7]은 0에서 6까지만. 슬라이싱도 Range와 같이 한 칸 전까지 포함. 대신 [1:1]은 1을 의미함.





### 최소직사각형(완)

**문제**
![[Pasted image 20231005233520.png]]
![[Pasted image 20231005233525.png]]

**나의 풀이**
![[Pasted image 20231005233543.png]]

**좋은 풀이**
![[Pasted image 20231005233715.png]]

==배운 점==
나랑 푸는 방식은 똑같은데 for 문에서 a,b에 값을 넣어줘서 훨씬 깔끔하게 구성됨.
저걸 몰라서 if문 두개로 일일이 인덱스 값을 넣으면서 풀었다.
**배열은 a,b를 통해 각각 값을 할당할 수 있다** - 기억하기 !
그리고 sort를 안하고 swap을 통해 앞에 큰 값을 몰아 넣음.
그 뒤 max 함수를 사용해 값 비교할 필요 없이 가장 큰 값을 꺼내서 곱해줌. 끝

**추가로 다른 방식의 좋은 풀이**
![[Pasted image 20231005234115.png]]
큰 것중의 큰 거 * 작은 것 중에 작은 거

### 숫자의 표현 (완)

**문제**
![[Pasted image 20231009165646.png]]

**나의 풀이**
![[Pasted image 20231009165657.png]]

**좋은 풀이**
![[Pasted image 20231009165717.png]]

**배운 점**
- while문에서 try횟수와 num의 숫자를 올려주는 방법 자체가 for문을 사용하면 저절로 올라감.
- 좋은 풀이에 있는 것 보다 range의 최대 범위를 num//2 + 1로 설정해주는게 쓸데없는 연산 없이 반복문을 빨리 종료할 수 있어서 더 좋음.


### 구명보트(복습)
**문제**
![[Pasted image 20231010020248.png]]

**코드**
![[Pasted image 20231010020303.png]]
처음에 짤 때 작은 값과 다른 값들을 하나하나 다 비교해봤다.
하지만, 가장 큰 값과 작은 값을 비교해서 두 개가 안묶이면 최대값은 혼자 빼낼 수 밖에 없는거니까 pop으로 빼내고 다시 그다음 작은 수랑 비교하는면 됨.
가장 작은 수는 계속 남아서 비교할 수 있으니까 다른 경우의 수를 생각할 필요가 없음.
문제풀이의 핵심은 최소값과 최대값을 비교해서 안되면 최대값을 빼면 되는 거였음.



### 타겟 넘버 BFS/DFS(복습)
**문제**
![[Pasted image 20231010145803.png]]

BFS 풀이
![[Pasted image 20231010145813.png]]
### 숫자 문자열과 영단어/프-1/실패

문제
![[Pasted image 20231012121539.png]]

나의 풀이
x

참고 풀이
![[Pasted image 20231012121557.png]]

배운 점
- 일일이 대입하면 코드가 너무 길어지고 복잡해지므로 딕셔너리로 풀어야 한다는 생각까진 했다. 하지만 딕셔너리 정보를 찾아봤음에도 딕셔너리가 작동하는 로직을 이해하지 못했다.
- 딕셔너리에 대해서 더 공부하기

### 가장 가까운 같은 글자/프-1/풀이참고

**문제**
![[Pasted image 20231012020559.png]]

**나의 풀이**
![[Pasted image 20231012020636.png]]

**좋은 풀이**
![[Pasted image 20231012020655.png]]

**배운 점**
내 풀이는 2중 반복문을 통해 기존꺼를 하나씩 빼서 뒤에부터 비교하는 방식이라면,
좋은 풀이는 빈 딕셔너리에 맨 앞분터 하나씩 추가하면서 안에 있는지 여부를 판별함.

## ==알고리즘 지식==

### **튜플을 사용하면 좋은 경우**
- 서로 다른 성질의 데이터를 묶어서 관리해야 할 때
	- 최단 경로 알고리즘에서 (비용,노드 번호) 형태로 튜플 자주 사용
- 데이터의 나열을 해싱(Hashing)의 키 값으로 사용할 때
- 리스트보다 메모리를 효율적으로 사용해야 할 때

### 실전에서 유용한 라이브러리
![[Pasted image 20231005190822.png]]
![[Pasted image 20231005190902.png]]
![[Pasted image 20231005190917.png]]
![[Pasted image 20231005190931.png]]
![[Pasted image 20231005190944.png]]










**그리디 알고리즘**
![[Pasted image 20231005191004.png]]



### 그리디 알고리즘(탐욕법)
- 현재 상황에서 가장 좋은 것만 고르는 방법

### DFS 알고리즘
![[Pasted image 20231006191158.png]]
스택이나 재귀함수를 통해 사용
### BFS 알고리즘
![[Pasted image 20231006191236.png]]
from collections import deque
queue = deque 이렇게 큐를 불러와서 사용
최단거리 탐색하기

**BFS 문제 예시**

**문제**
![[Pasted image 20231010140851.png]]

**아이디어**
![[Pasted image 20231010140651.png]]

**코드**
![[Pasted image 20231010140757.png]]

### 정렬

**선택정렬**
- 2중 for문으로 구성
- 앞의 항을 뒤에 모든 항과 하나씩 비교해가면서 뒤에 항이 더 크면 스와핑
- 시간복잡도 : O(n^2)

**삽입정렬**
- 항을 하나 지정하고 앞에 항이 더 작으면 그대로 있고, 더 크면 위치를 바꾸고 멈출때까지 계속 비교

**퀵 정렬**

**계수정렬**
- 데이터의 최대값만큼 항을 구성해서 데이터가 몇번 등장하는지 count하고 반환한다.
- 공간 복잡도는 높지만
- 시간 복잡도는 O(n + k)를 보장






def ten_two(num):
    result = ''
    while num > 0:
        num,b = num // 2, num % 2
        result += str(b)

    return result[::-1]

def solution(n, arr1, arr2):
    answer = ''
    result = []
    temp = []
    map = [] * n
    for i in range(n):
        temp.append(str((int(ten_two(arr1[i])) + int(ten_two(arr2[i])))))
        
        
    for k in range(len(temp)):
        for j in range(len(temp[k])):
            if int(temp[k][j]) >= 1:
                map[k].append("#")
            else:
                map[k].append(" ")
    print(temp)
    return answer
