
## Chapter 02(UI 커스터마이징)

#### 윈도우와 뷰
IOS에서 실행되는 애플리케이션에는기본적으로는 디스플레이가 한 개이므로 생성하는 윈도우 역시 한 개이지만, **외부 디스플레이가 연결될 경우** 두 번째 디스플레시에 콘텐츠를 표현하기 위해 **새로운 윈도우 객체를 생성**한다.

윈도우 내부에는 수 많은 뷰 포함.
각각의 뷰는 각자 영역에서 원하는 내용 표시.
윈도우와 뷰 사이는 뷰 컨트롤러를 통해 연결.

**뷰 컨트롤러**는 뷰의 계층을 관리하여 윈도우에 전달하고, 디바이스에서 감지된 터치 이벤트를 윈도우로부터 전달받아 처리하는 역할을 한다.

**윈도우**는 **뷰** 직접 참조 X -> **뷰 컨트롤러**가 그 사이를 중계
	이를 통해 윈도우 객체 하나가 모든 뷰를 관리해야하는 불상사 막아줌.


**윈도우 객체**는 하나의 뷰 컨트롤러를 **루트 뷰 컨트롤러**로 지정하여 참조.
##### img
![[스크린샷 2025-03-20 오후 11.44.48.png]]

##### ---
루트 뷰 컨트롤러는 윈도우와 연결하기 위한 뷰 컨트롤러 집단의 대표
윈도우 객체는 항상 **루트 뷰 컨트롤러**만을 참조, 관리.
	**나머지 뷰 컨트롤러**들은 윈도우 객체의 직접적인 관리 대상 X

**뷰 컨트롤러**
- 하나의 뷰 컨트롤러는 하나씩의 화면을 담당하고 이를 **씬(Scene)** 이라고 한다.
- **콘텐츠 뷰 컨트롤러:** 씬을 담당하여 콘텐츠를 표시 (이미지나 레이블같은 콘텐츠를 올려놓을 수 있다면 콘텐츠 뷰 컨트롤러)
- **컨테이너 뷰 컨트롤러:** 씬을 담당하지 않고 다른 뷰 컨트롤러와의 **연결 관계**를 관리
- 뷰 컨트롤러 내부는 **수많은 뷰(view)** 로 이루어짐.
	- **뷰의 계층 구조**
	- 각각의 뷰는 자기 자신을 스크린 상에 표시하기도 하지만, 다른 뷰 객체를 포함하는 컨테이너의 역할도 수행.
		- **슈퍼 뷰(Superview)** : 다른 뷰를 포함하는 뷰. 서브 뷰가 레이아웃을 구성할 수 있도록 좌표 체계 제공.
		- **서브 뷰(Subview)** : 슈퍼 뷰에 포함된 뷰. 슈퍼 뷰를 기준으로 레이아웃 구성.
		- 뷰들은 서로 상대적인 레이아웃을 이루기 때문에, 하나의 뷰는 슈퍼 뷰가 되기도 하고, 서브 뷰가 되기도 한다.
		- 최상위 뷰는 **루트 뷰(Root View)** 또는 **콘텐츠 뷰(Contents View)** 라고 한다.

**테이블 뷰 컨트롤러**에서는 **테이블 뷰**가 **루트 뷰**이고,
**컬렉션 뷰 컨트롤러**에서는 **컬렉션 뷰**가 **루트 뷰**이다.

커스텀 뷰 컨트롤러를 정의할 때는 대개 다음 클래스들 중 하나를 골라 서브 클래싱한다.
- 테이블 뷰 컨트롤러(UITableViewController)
- 컬렉션 뷰 컨트롤러(UICollectionViewController)
- 스크롤 뷰 컨트롤러(UIScrollViewController)
- 일반 뷰 컨트롤러(UIViewController)

![[스크린샷 2025-03-21 오전 10.23.06.png]]
뷰는 다양한 요소들을 종합하여 객체들이 화면에 어떻게 구현될지 결정한 다음, 슈퍼 뷰로 전달한다. 슈퍼 뷰는 이를 받아 다시 자신의 슈퍼 뷰에게 전달하고 최종적으로 루트 뷰는 계층을 거슬러 전달된 모든 서브 뷰와 이들 사이의 상대적 레이아웃을 종합하여 하나의 씬으로 제작한 뒤 윈도우 객체에 전달한다.

#### 커스터마이징
스토리 보드로 인터페이스를 구성하는 것은 모두 XML 데이터로 저장된다.
결국 직접 코드를 입력하지 않을 뿐, XML 파일을 작성하는 것과 같다.

#### 코코아 터치 프레임워크(Cocoa Touch Framework)
애플의 모든 모바일 기기에서 구동되는 애플리케이션을 개발할 때 사용되는 통합 프레임워크.
애플 모바일 기기에서 필요한 기능, 동작구조, UI를 구성하는 기본 객체들을 모두 담고있는 유일한 프레임워크이기 때문에, 이 프레임워크를 이용하지 않으면 IOS용 애플리케이션을 만들 수 없다.

코코아터치 프레임워크는 크게 **파운데이션(Foundation) 프레임워크**와 **UIKit 프레임워크**로 이루어진다.

==**파운데이션 프레임워크**==
애플리케이션의 중심이자 기능적인 면을 담당. (**공통적인 기능 처리**)

기존 자료형을 포함한 자료구조, 객체 지향 처리와 연산, 각종 구조체나 타이머, 네트워크 통신 등 모바일 애플리케이션으로서의 특징적 기능에 직접 연관되지 않은 대부분의 기본적인 애플리케이션 기능을 처리한다.

이 프레임워크에 속한 개체들은 대부분 **NS**라는 키워드로 시작한다.
`NSIndexPath가 IndexPath로 단순해진 것처럼 예외도 있다.`

==**UIKit 프레임워크**==
화면, UI, 앱의 동작 등 모바일 애플리케이션으로서의 기능 구현을 주로 담당.
화면과 사용자의 상호반응, 화면의 구조를 만들고 관리 하는 등 앱의 특성이라고 생각하는 대부분의 기능 구현에 **UIKit**이 관여한다.

**클래스는 단일 상속만 가능하다**
콜론(:) 뒤에 여러개가 있다면, 첫 번째를 제외한 나머지는 모두 프로토콜이므로 상속이 아닌 **구현**을 의미한다.

객체가 Action 메서드를 구현하려면 UIView가 아닌 UIControl을 상속받아야 한다.


새로 씬 델리게이트 클래스를 구현하기 위해서는 다음 네 가지 조건을 만족해야 한다.

1. UIResponder 클래스를 상속받아야 한다.
2. UIWindowSceneDelegate 프로토콜을 구현해야 한다.
3. UIWindow 타입의 멤버 변수 window가 정의되어 있어야 한다.
4. Info.plist 파일의 `[Delegate Class Name]` 항목에 등록되어 있어야 한다.



#### 내비게이션

내비게이션 컨트롤러를 연결하고 나면, **내비게이션 컨트롤러의 관리**를 받는 모든 뷰 컨트롤러에 내비게이션 바가 삽입된다. **내비게이션 컨트롤러의 관리**란, 뷰 컨트롤러 사이의 이동을 **내비게이션 컨트롤러에 의존하**는 것을 이야기한다.

**보통 뷰 컨트롤러 사이의 이동은 구조적 측면에서 크게 두 가지 방식으로 분류할 수 있다.**
> 1. 현재의 뷰 컨트롤러가 새로운 뷰 컨트롤러를 띄워주는 방식
> 2. 내비게이션 컨트롤러가 현재의 뷰 컨트롤러 위에 새로운 뷰 컨트롤러를 띄워주는 방식.

두 가지 방식은 **화면 이동 주체**를 생각해보면 차이가 꽤 크다.
**전자** -> **현재 화면에 표시되고 있는 뷰 컨트롤러**
**후자** -> **내비게이션 컨트롤러**

쉽게 말해 집을 계약할 때 당사자들끼리 직접 계약서를 작성하는 방식과, 부동산을 통해 계약서를 작성하는 방식이라고 생각하면 된다.

**내비게이션 바**는 **오직 내비게이션 컨트롤러를 이용하여 화면을 이동**했을 때에만 표시된다.

정리해보면, 뷰 컨트롤러 상단에 내비게이션 바가 의미하는 바는 다음과 같다.
> *"현재 이 화면은 내비게이션 컨트롤러의 관리 하에 있습니다."*

**내비게이션 바**와 **내비게이션 아이템**은 **탭 바**와 **탭 바 아이템**의 **관계**와 비슷하다.
내비게이션 바는 **내비게이션 컨트롤러**에 속한 객체이며, 내비게이션 아이템은 **뷰 컨트롤러**에 속한 객체이다. 그래서 내비게이션 아이템을 화면에 추가할 때에는 내비게이션 컨트롤러가 아니라 뷰 컨트롤러에 추가해야 하며, 참조할 때에도 역시 뷰 컨트롤러를 거쳐야 한다.


#### 클래스의 초기화 메소드
스위프트에서 저장 프로퍼티의 자동 초기화는 옵셔널 타입으로 선언된 경우에만 제한적으로 허용된다. 따라서, 옵셔널 타입으로 선언되지 않은 모든 저장 프로퍼티는 인스턴스가 생성되기 전에 반드시 초기값이 설정되어야 한다.

**스위프트에서 객체의 인스턴스가 생성되었음에도 초기값을 가지지 못하는 저장 프로퍼티는 존재할 수 없다.**

**구조체(Struct)** 에서는 내부적으로 정의된 모든 저장 프로퍼티를 초기화해 주는 쵝화 메소드가 자동으로 제공된다.
이를 **멤버와이즈(Memberwise)** 초기화 메소드라고 하는데, 저장 프로퍼티를 일반적으로 객체의 **멤버 변수**라고 부르는 데에서 유래한 이름이다.

클래스는 멤버와이즈 초기화 메소드가 제공되지 않기 때문에, 저장 프로퍼티의 초기값을 지정해주거나, 초기화 메소드를 통해 명시적으로 초기화해야 한다.

---
> 만약, 모든 저장 프로티가 초기화 되어 있다면, 기본 초기화 메소드를 사용하여 인스턴스를 생성할 수 있다.

```
class Boo {
	var v: Int = 0
	var c: String = ""
}

let s = Boo.init() // 여기서 .init()은 아래처럼 생략이 가능하다.

let s = Boo
```
---

##### 지정 초기화 메소드와 편의 초기화 메소드

클래스는 여러 개의 초기화 메소드를 가지고 있다.
**초기화 메소드** 사이에서도 코드 **중복을 최소화**하면서 **델리게이션**이 가지는 목적을 달성하기 위해 **지정 초기화 메소드**와 **편의 초기화 메소드**로 나누어진다.

이들은 일정한 규칙에 의해 **초기화 체인(Initializer Chain)** 이라는 관계를 구성하면서 메소드 사이 중복을 최소화한다.

***지정 초기화 메소드***
클래스의 메인 초기화 메소드이다. 초기화 과정에서 해당 클래스의 모든 저장 프로퍼티를 초기화해야 하는 의무를 가진다. 또한, 부모의 초기화 메소드를 호출함으로써 상속받은 모든 저장 프로퍼티까지 초기화한다.

일반적으로 **지정 초기화 메소드**는 보통 하나인 경우가 많다.

***편의 초기화 메소드***
사용에 편의를 주기 위해 정의하는 보조적인 초기화 메소드.
일부 혹은 전체 멤버에 대해서 별도의 초기값을 설정하는 동시에, 내부적으로 다른 초기화 메소드를 다시 호출.

일반적으로 구분하기 위해 `convenience`키워드를 붙여준다.

![[Pasted image 20250401125826.png]]
> 클래스 초기화 과정에서 **편의 초기화 메소드**는 같은 클래스 내에 정의된 다른 초기화 메소드를 호출하는 식으로 **연쇄 초기화**를 시도하는데, 이 과정에서 최종적으로 **지정 초기화 메소드**가 호출되어야 한다.

***결론***
1. **지정 초기화 메소드는 항상 상위 방향으로 호출한다.**
2. **편의 초기화 메소드는 항상 수평 방향으로 호출한다.**


스위프트에서 클래스  초기화는 2단계에 걸처 이루어진다.
1단계 초기화에서는 부모 방향으로 거슬러 올라가면서 모든 프로퍼티의 초기값을 만들어주고,
2단계 초기화에서는 다시 자식 방향으로 내려오면서 초기화된 프로퍼티 중 일부를 필요에 맞게 커스터마이징한다. 이때 컴파일러는 2단계 초기화를 오류 없이 완료할 수 있도록 다음의 안전 점검을 수행한다.

![[Pasted image 20250401130935.png]]
> 안전점검 4에서 볼 수 있듯이, 1단계가 끝나기 전까지 클래스 인스턴스는 메모리 상으로 완전히 초기화된 상태가 아니다. 따라서 인스턴스 메소드나 인스턴스 프로퍼티, self 참조를 사용할 수 없다.

***2단계 초기화 과정***
![[Pasted image 20250401131316.png]]



##### 관점 지향 프로그래밍 AOP(Aspect Oriented Programming)
**목적에 따라** 코드의 작성 **위치**를 구분

`객체 지향 프로그래밍 (OOP)`를 보완하기 위한 개념으로, 클라이언트 프로그래밍보다는 서버 프로그래밍에서 많이 사용.


#### 접근 제한자
접근 제한자는 클래스나 메소드, 프로퍼티 앞에 작성되어 개별 객체와 속성에 대한 접근을 단계별로 허용하거나 차단하는 기능을 수행.

>• **private** : 같은 **클래스** 내에서만 접근 가능
>• **fileprivate** : 같은 **파일** 내에서 접근 가능
>• **internal** : 같은 **모듈** 또는 **프로젝트** 내에서 접근 가능
>• **public** : **모듈 외부**에서 접근이 가능하지만, 상속이나 메소드 오버라이드가 허용되지 않으며 **참조**하여 사용하는 것만 허용
>• **open** : public의 범위를 가지며, 상속이나 메소드 오버라이드까지 **모두 허용**

접근 제한자를 선언하지 않으면 기본적으로 **internal** 범위를 적용.


#### 프로퍼티 리스트(Property List)

**비교적 단순한 테이터를 XML 포맷에 맞추어 `키(Key) - 값(Value)` 형식으로 저장하는 것**

프로퍼티 리스트는 데이터의 타입을 **추상화**하여 저장한다.
여기서 **추상화**란 **구체화**의 반대말로서, 일체의 개별적인 특성을 배제하고 공통성을 띄는 것을 의미한다.
개별적인 특성이 없기 때문에, 여러 객체로 분화할 수 있는 가능성을 가진 일종의 줄기세포 같은 형태를 의미.

#### 메소드 오버로딩(Method Overloading)
메소드의 이름과 매개변수명은 모두 동일하되 매개변수의 타입만 다른 메소드를 여러 개 정의할 수 있는 문법.

오버로딩 문법을 활용하면 하나의 이름과 형식으로 여러 타입과 매개변수를 지원하는 각각의 메소드를 작성할 수 있으므로 타입 안정성을 높일 수 있다.


#### 코어 데이터

애플이 코코아 개발 환경을 통해 제공하는 **인메모리(In-Memory)** 방식의 데이터 관리 프레임워크.

---

> **코어 데이터는 대량의 읽기와 쓰기 작업이 발생하더라도 성능에 크게 영향을 끼치지 않는다.**

코어 데이터는 **인메모리** 방식이므로 데이터를 다루는 모든 작업은 메모리를 기반으로 동작한다.
즉, **코어 데이터**를 통해 읽고 쓰는 모든 데이터는 원칙적으로 **메모리에 로드된 다음**에 처리된다.

그에 반해, 데이터베이스는 대부분의 작업이 영구 저장소에서 직접 처리되고, 효율성을 위해 읽기 목적의 데이터 일부만 메모리에 올려 놓고 사용한다.

또한, 코어 데이터는 인메모리 기반이라 하더라도 내부적으로는 파일이나 **SQLite**같은 영구 저장소에 보조적으로 데이터를 저장할 수 있기 때문에, 앱이 종료되더라도 데이터가 삭제되지는 않는다.

---

> **코어 데이터는 데이터베이스가 아니다.**

인메모리 방식이지만 **데이터를 영구적으로 보존**할 수 있다는 점, **데이터베이스의 데이터 구조를 거의 그대로 사용**한다는 점, **검색이나 정렬같은 핵심 쿼리 기능을 모두 지원**한다는 점들 때문에 **코어 데이터**는 종종 데이터베이스로 **오해**받기도 하지만 데이터베이스가 아니다.

코어 데이터는 여러 계층에서 서로 협력하는 다양한 **객체**들로 이루어져 있다.

애플에서는 코어 데이터를 **"애플리케이션에서 모델(Model) 계층의 객체를 관리하는 데 사용하는 프레임워크이자, 라이프 사이클이나 영속성 관리를 위한 기능을 제공하는 객체 그래프 관리자(Object Graph Manager)"** 로 정의한다.
여기서 그래프는 **노드(Node)** 와 **간선(Link)** 로 이루어진 도형을 의미한다. 코어 데이터가 이야기하는 **객체 그래프**의 개념과 유사하다. 객체 지향 프로그래밍에서 객체란 **독립적이고 자체적인 생명 주기를 가지면서 속성과 기능으로 이루어진 단위 구성체**를 의미한다.

다만, 객체가 독립적이라는 것은 다른 객체와 단절되거나 고립된 것을 의미하지는 않는다.

코어 데이터에서 정규화된 데이터 객체는 다른 객체와 참조 관계 하에 있으며, 서로 관의 관계를 통해 데이터의 완전성을 보장받을 수 있다.
이때 객체를 하나의 노드로 간주하고, 서로 간의 연관 관계를 링크로 이어보면 다양하게 연결되는 복합적인 그래프 형태의 도형을 얻게 되는데, 이것이 바로 **객체 그래프**이다.

![[Pasted image 20250409194719.png]]
> `객체 그래프`

코어 데이터가 객체 그래프의 관리를 담당한다는 것은, **객체 A를 객체 B와 연결할 수 있으며 이 연결을 통해 A와 B는 영속적으로 동기화 된다** 라는 것을 의미한다.
객체 A에서 업데이트가 발생하면 이에 연결된 객체 B에서도 연관된 데이터의 업데이트가 수행된다. 또한 한쪽에서 객체를 삭제하면 연결을 타고 연이어 객체 B에서도 관련된 데이터가 삭제되기도 한다.

정리해보자면 코어 데이터는 전체적으로 데이터베이스와 비슷한 기능을 제공하지만, 엄밀하게 말해 데이터 저장에 관련된 기능을 제공하는 프레임워크라고 할 수 있다. 또한 데이터를 객체로 다루며, 정규화된 데이터 사이의 참조 관계를 바탕으로 한쪽 객체에서 발생한 변경 내용을 다른 쪽 객체에도 전파하는 등 객체 간 관계의 일관성을 유지하는 객체 그래프 관리자로서의 특징을 가진다.

이 때문에 코어 데이터를 마치 데이터베이스인 양 사용해도 문제가 되지 않는다.

![[Pasted image 20250409202033.png]]
> `코어 데이터의 내부 구조`


> **코어 데이터의 한계**

**1. 데이터를 메모리에 로딩하는 과정 없이는 작업이 불가능하다.**
항상 메모리에 올려놓아야 하기 때문에 성능 하락이 발생할 수 있다.

**2. 데이터 로직을 다루는 데에 한계가 있다.**
관리 객체 모델의 서브 클래스를 만드는 경우 원하는 대로 오버라이드가 가능한데, 이를 통해 변경된 내용을 코어 데이터가 확인할 수 있는 방법이 없다.
쉽게 말해서 위에서 중복 입력 방지를 했다고 하더라도, 아래에서 중복 입력이 가능하게 바꿔버리면 코어 데이터는 이 내용을 알 수 없다.

이처럼 자신의 영역을 벗어나는 데이터 로직에 대해서는 관여할 수 없기 때문에, 이를 비즈니스 로직으로 처리해야 한다.

**3. 멀티 스레드, 멀티 유저를 지원하지 않는다.**
일반적으로 멀티 스레드, 멀티 유저를 지원하는 다른 데이터베이스와 달리 코어 데이터는 **싱글 스레드**만 지원한다.

---





