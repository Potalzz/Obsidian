1. 프로젝트 리스트에서 프로젝트를 생성버튼 클릭
2. 해당 프로젝트에 속한 volume을 생성후 프로젝트에 포함시켜 프로젝트 생성
3. 해당 프로젝트에 속한 volume을 띄운다.
	volume을 띄우는 방식은 ?
	1. volume Scene의 realityView에서 실행된 projectID를 통해 cache를 탐색하고 volume이 존재하면 가져와서 realityView에서 그리고,
	2. 존재하지 않으면 새로 entity를 만들어서 cache에 추가하고 가져온다.

**프로젝트** --`생성할 프로젝트 정보`-->  **프로젝트 리스트 뷰모델** --> 

volumeWindowViewModel에서 projectiD가 존재하지 않는 entity는 캐시에서 제거하는 함수 구현


#### 싱글톤 -> 환경변수 리팩토링
도입 순서 제안(마이그레이션 체크리스트)

• 1단계: AppSceneState에 @MainActor 추가, volumeWindowID를 static let으로 변경, getter/setter 제거(또는 private(set) + select/clear로 정리)

• 2단계: SpacialMoodBoardApp에서 AppSceneState 인스턴스를 만들고 .environment(appSceneState)로 각 WindowGroup에 주입. 모든 사용처를 @Environment(AppSceneState.self)로 전환. openWindow(id:)는 정적 상수 사용

• 3단계: VolumeSceneViewModel, ProjectListViewModel에서 AppSceneState.shared 의존 제거 → 생성자 주입

• 4단계: SceneModel과 선택 상태의 단일 소스화(중복 제거). 필요 시 ProjectSelectionState로 역할 분리

• 5단계: @SceneStorage로 씬 단위 activeProjectID 복원

• 6단계: FilePathProvider를 project.id 기반 구조로 리팩터링(제목-의존성 제거). 제목 변경 시 파일 이동/리네이밍 없이 메타데이터만 갱신

  

이 내용을 코드로 반영하려면 다음 타입/구성의 실제 구현을 함께 봐야 정확히 제안할 수 있습니다. 공유해 주시면 파일 단위로 “전체 내용”을 보존하며 수정안을 드리겠습니다.

• ProjectRepository/InmemoryProjectRepository의 프로토콜/구현

• VolumeSceneView/ImmersiveView에서 상태 주입 방식

• AppModel(특히 immersiveSpaceID/state)과 App Scene 구성(WindowGroup/ImmersiveSpace)

• AppSceneState를 @Environment로 사용하는 대상 뷰들