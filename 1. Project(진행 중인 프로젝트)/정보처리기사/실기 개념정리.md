# 오답 정리
***각 문제당 3번씩 꼭 풀기!!***
**문제 풀때 반환 타입 한 번 더 확인**
**출력 행이랑 답 확인하기**
**실행하지 않은 메서드 없나 한 번 더 확인**


### 리눅스 파일 권한 부여



### UML다이어그램
> 고객/개발자간 원활한 의사소통을 위해 **표준화한 대표적 객체지향 모델링 언어**

#### 1. 사물(Things)
- 구조(개념, 물리적 요소)
- 행동
- 그룹
- 주해(부가적 설명, 제약조건)

#### 2. 관계(Relationship)
- **연관 관계(Association)** : 2개 이상의 사물이 서로 관련
- **집합 관계(Aggregation)** : 하나의 사물이 다른 사물에 포함(전체 -부분 관계)
- **포함 관계(Composition)** : 집합 관계 내 한 사물의 변화가 다른 사물에게 영향
- **일반화 관계(Generalization)** : 한 사물이 다른 사물에 비해 일반/구체적인지 표현 `(한 클래스가 다른 클래스)`
- **의존 관계(Dependency)** : 사물 간 서로에게 영향을 주는 관계 `(한 클래스가 다른 클래스의 기능을 사용할 때)`
- **실체화 관계(Realization)** : 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정 / 서로를 그룹화할 수 있는 관계

#### 3. 다이어그램(Diagram)
![[Pasted image 20250718130034.png]]

**구조 다이어그램: 클배객패컴컴**
**행위 다이어그램: 유타상활시커상**

### 테스트
> 테스트는 기본적으로 결함이 존재함을 밝히는 것 `(무결함을 증명할 수는 없음)`

**살충제 패러독스:** 동일한 테스트 케이스에 의한 반복 테스트는 새로운 버그 발견X

![[Pasted image 20250718130406.png]]

#### 화이트 박스 테스트
![[Pasted image 20250718130424.png]]

#### 블랙박스 테스트
![[Pasted image 20250718130444.png]]


---

### 네트워크
![[Pasted image 20250718130535.png]]



**URL구조**

**네트워크 프로토콜**

**네트워크 종류**

#### 프로토콜
> 정보 교한을 위해 무엇을, 어떻게, 언제 통신할 것인지를 정한 **통신 규약**

프로토콜은 **3가지** 기능이 있다.
1. **흐름 제어:** 패킷 흐름(전송량/속도)을 조정하야 송수신 안정성 유지
2. **동기화:** 송/수신이 같은 상태를 유지
3. **오류 제어:** 전송 중 발생한 오류를 검출, 복원/정정

##### 네트워크 계층 프로토콜
![[Pasted image 20250718131558.png]]

##### 전송 계층 프로토콜
![[Pasted image 20250718131620.png]]

##### 응용 계층 프로토콜
![[Pasted image 20250718131630.png]]


#### 통신 방식
##### 1. OAuth
- **어떤 분야?**  
    ▶ **보안 / 인증 프로토콜**
    
- **설명**  
    - 사용자가 **자신의 로그인 정보를 외부 서비스에 직접 제공하지 않고**,  
    **제3자 애플리케이션이 대신 접근 권한을 위임받는 방식**  
    - 구글, 페이스북, 네이버 로그인 등에 사용
    
- **핵심 키워드**  
    - 위임(Authorization), 토큰 기반 접근, 사용자 비밀번호 공유 안 함
    
> 🔸 예: 페이스북 계정으로 외부 앱 로그인 시 비밀번호 안 넣고도 인증 가능

##### 2. IPC (Inter-Process Communication)
- **어떤 분야?**  
    ▶ **운영체제 / 프로세스 간 통신**
    
- **설명**  
    ▶ 하나의 컴퓨터 안에서 **프로세스끼리 데이터를 주고받기 위한 방법**
    
- **종류 (실기 자주 출제)**

| 방식                     | 설명                      |
| ---------------------- | ----------------------- |
| 파이프 (Pipe)             | 단방향 통신. 부모-자식 프로세스 간 사용 |
| 메시지 큐 (Message Queue)  | 큐에 데이터를 넣고 빼는 방식        |
| 공유 메모리 (Shared Memory) | 메모리 공간을 함께 쓰는 고속 방식     |
| 세마포어 (Semaphore)       | 동기화 제어 (자원 접근 제어용)      |
| 소켓 (Socket)            | 네트워크 기반 프로세스 간 통신       |
##### 3. Ad-hoc Network
- **어떤 분야?**  
    -  **네트워크 / 무선통신**
- **설명**  
    - **기지국 없이도 노드끼리 직접 연결**해 통신하는 임시 네트워크  
    - 노드 간 **멀티 홉 라우팅**으로 커버리지 확장 가능
    
- **활용 예시**  
    - 전쟁터, 재난 구조, 임시 회의 등
    
- **핵심 키워드**  
	- 인프라 없이 구축, 유동적 토폴로지, 분산 네트워크


#### 정보 전송 방식
![[Pasted image 20250718131826.png]]

#### 패킷 교환 방식
![[Pasted image 20250718131738.png]]


### 보안
![[Pasted image 20250718131957.png]]

#### 정보 보안 프로토콜
![[Pasted image 20250718132026.png]]





**접근 통제**

![[Pasted image 20250718133412.png]]

**네트워크 공격**

### 키
**키별 의미**

### 클라우드 서비스
![[Pasted image 20250718133458.png]]


### 데이터 베이스
![[Pasted image 20250718133659.png]]

#### 무결성
![[Pasted image 20250718133531.png]]


#### 접근 통제
![[Pasted image 20250718133602.png]]

#### 키
![[Pasted image 20250718133637.png]]

#### 정규화
![[Pasted image 20250718133719.png]]

#### 조인
![[Pasted image 20250718133953.png]]

### 디자인 패턴
> - 서브시스템에 속하는 컴포넌트들과 그 관계를 설계하기 위한 참조 모델
> - 객체 지향 프로그래밍 설계 시 자주 발생하는 문제에 대한 반복적 해결 방법

#### 생성 패턴
> 객체 생성 과정을 추상화하여, 유연하고 재사용 가능한 객체 생성을 돕는 패턴

![[Pasted image 20250718133914.png]]

#### 구조 패턴
> 클래스나 객체를 조합해서 더 큰 구조를 만들 때 사용

![[Pasted image 20250718133924.png]]

#### 행위 패턴
> 객체나 클래스 사이 책임 분산과 커뮤니케이션 방법 관련

![[Pasted image 20250718133936.png]]


### URL구조
![[Pasted image 20250718134131.png]]



# 진수
## 진수의 종류와 개념

진수란 숫자를 표현하는 방식 중 하나로, **기수법(radix system)** 이라고도 한다.
어떤 진수냐에 따라 사용하는 숫자의 범위와 자리값이 달라짐.

### 1. **2진수(Binary, 기수: 2)**

- **사용 숫자:** 0, 1
- **자릿값:** 2의 거듭제곱
- **사용 예:** 컴퓨터 내부에서 사용하는 기본 진법
- **예:** `1011₂` = 1×2³ + 0×2² + 1×2¹ + 1×2⁰ = **11₁₀**

### 2. **8진수(Octal, 기수: 8)**

- **사용 숫자:** 0 ~ 7
- **자릿값:** 8의 거듭제곱
- **사용 예:** 3비트를 1자리로 표현 → 2진수를 간결하게 나타낼 때 사용
- **예:** `17₈` = 1×8¹ + 7×8⁰ = **15₁₀**

### 3. **10진수(Decimal, 기수: 10)**

- **사용 숫자:** 0 ~ 9
- **자릿값:** 10의 거듭제곱
- **사용 예:** 우리가 일상적으로 사용하는 진법
- **예:** `325₁₀` = 3×10² + 2×10¹ + 5×10⁰

### 4. **16진수(Hexadecimal, 기수: 16)**

- **사용 숫자:** 0~9, A(10), B(11), C(12), D(13), E(14), F(15)
- **자릿값:** 16의 거듭제곱
- **사용 예:** 4비트를 1자리로 표현 → 2진수를 더 간결하게 나타낼 때 사용
- **예:** `1A₁₆` = 1×16¹ + 10×16⁰ = **26₁₀**

---

### 🧠 실기 시험 대비 핵심 포인트

- 진법 변환(2진수 ↔ 10진수, 2진수 ↔ 8진수, 2진수 ↔ 16진수)
- 비트와 바이트 단위 변환
- 2진수의 보수 계산(1의보수, 2의 보수)
- 정수/실수의 이진 표현 방식


## C언어

### 포인터
>C언어에서 포인터는 **메모리 주소를 저장하는 변수**를 의미한다. 
>즉, 일반 변수는 값을 저장하지만, 포인터는 **값이 저장된 메모리의 위치(주소)를 저장**한다.

***이중 포인터는 반드시 포인터의 주소를 가리켜야 한다!!***
``` c
char *p = "Hello";     // p는 문자열 "Hello"의 첫 글자를 가리켜
char **pp = &p;        // pp는 p의 주소를 가리켜
```

**각 요소의 의미**
- `a`: 정수형 변수, 값은 `10`
- `&a`: 변수 `a`의 주소값
- `p`: `int`형 포인터 변수
- `*p`: 포인터 `p`가 가리키는 주소의 값 (즉, `a`) 

#### 포인터의 선언
```
int *p;     // int형을 가리키는 포인터
float *fp;  // float형을 가리키는 포인터
char *cp;   // char형을 가리키는 포인터
```
> 자료형과 일치하는 포인터를 사용해야 한다.

---

#### 포인터의 주요 연산

|연산|설명|예시|
|---|---|---|
|`&`|주소 연산자|`&a`는 변수 `a`의 주소|
|`*`|간접 참조 (역참조) 연산자|`*p`는 `p`가 가리키는 주소의 값|
|`p + 1`|다음 요소의 주소 (자료형 크기만큼 이동)|`int *p`라면 `p+1`은 4바이트 뒤 주소|

---

#### 예제 코드

```
#include <stdio.h>

int main() {
    int a = 10;
    int *p = &a;

    printf("a의 주소: %p\n", &a);
    printf("p의 값 (a의 주소): %p\n", p);
    printf("*p의 값 (a의 값): %d\n", *p);

    return 0;
```

---

#### 포인터의 활용

1. **함수에서 값 변경**
  
	- 포인터를 통해 인자의 실제 값을 바꿀 수 있다.
```
void change(int *p) {
    *p = 100;
}

int main() {
    int a = 10;
    change(&a);
    printf("%d\n", a);  // 출력: 100
}
```

2. **배열과 포인터**
    
    - 배열 이름은 곧 첫 번째 요소의 주소이므로 포인터처럼 사용 가능하다.
```
int arr[3] = {1, 2, 3};
int *p = arr;

printf("%d\n", *(p + 1));  // 출력: 2
```
3. **문자열 처리**
    
    - 문자열 리터럴은 `char *` 포인터로 다룬다.
```
char *str = "Hello";
printf("%c\n", *(str + 1));  // 출력: e
```


### 널 문자
>C 언어에서 문자열의 끝은 **`'\0'`** (널 문자)로 표시함.
>문자열은 단순히 문자 배열이지만, 끝을 알 수 있게 **마지막에 `'\0'`을 자동으로 붙여준다.**



---
## Java언어

### 생성자
> 클래스 이름과 동일한 이름을 가진 **특별한 메서드**

**특징**
- 반환형이 없다(void 조차 쓰지 않음).
- 객체가 생성될 때 딱 한 번 자동으로 호출된다.
- 주로 멤버 변수 초기화 같은 작업을 한다.

**예**
``` java
public cond(int v) {
	value = v;
}
```

### 추상 클래스와 형 변환의 개요
**추상 메소드**
>자식 클래스에서 재정의해야만 사용할 수 있는 메소드

**추상 클래스**
>추상 메소드를 하나 이상 포함하는 클래스

**클래스의 형 변환**
>부모 클래스의 객체 변수를 선언할 때 자식 클래스의 생성자를 이용하면,
>부모 클래스의 객체 변수를 통해 추상 메소드를 사용할 수 있다.


### 메서드

#### `.equals()`와 `==`의 차이

`==` → **참조값(주소)** 비교 (같은 객체인가?)
`.equals()` **->** **내용(값)** 비교(같은 내용인가 ?)

문자열 같은 경우에는 무조건 `.equals()`를 사용해야 정확한 값 비교가 된다.

### 출력

**출력 메서드 종류**

| 메서드                    | 설명                                       |
| ---------------------- | ---------------------------------------- |
| `System.out.print()`   | 줄바꿈 없이 출력                                |
| `System.out.println()` | 출력 후 **자동으로 줄바꿈**                        |
| `System.out.printf()`  | **형식을 지정(format)**해서 출력 (C언어 `printf`처럼) |

**출력 형식**
`System.out.printf("%d, %d\n", i, j)`
**Java**는 `""` 쌍따옴표 사이에 출력 형식에 맞춰 출력이 된다.

따라서 `%d`와 `%d\n`사이에 **콤마**`,`가 있으므로, 출력할 때 두 개의 요소 사이에 콤마를 붙여서 출력한다.


### 제네릭(generic)
> "자료형(type)을 나중에 정할 수 있게 미리 비워두는 틀"
- 클래스, 인터페이스, 메서드를 정의할 때 타입을 일반화해서 코드 재사용성을 높이고, 타입 안정성을 보장해준다.

#### 제네릭은 왜 사용할까 ?

**먼저, 제네릭을 사용하지 않는 경우를 먼저 살펴보자.**

예를 들어 `박스(Box)`라는 클래스가 있고, 여기에 뭔가 값을 담고 싶다.
```java
public class Box {
    private Object item;

    public void set(Object item) {
        this.item = item;
    }

    public Object get() {
        return item;
    }
}
```
사용할 땐:
```java
Box box = new Box();
box.set("Hello");
String s = (String) box.get();  // (String) 형변환 필요
```
**문제점:**
- `Object`는 아무거나 다 넣을 수 있어서, 잘못된 타입도 들어감.
- 꺼낼 때 무조건 **형변환**해야 해서 불편하고, 실수로 잘못 형변환하면 프로그램이 터질 수도 있다.

#### 제네릭을 쓰는 경우

이제 `Box`를 제네릭으로 바꿔보자.

```java
public class Box<T> {
    private T item;

    public void set(T item) {
        this.item = item;
    }

    public T get() {
        return item;
    }
}
```
여기서 `<T>`는 **타입을 나중에 정하겠다는 뜻**.
박스를 쓸 때 어떤 타입으로 쓸지 결정할 수 있다.

---

###  제네릭 박스 사용 예

```java
Box<String> stringBox = new Box<>();
stringBox.set("Hello");
String s = stringBox.get();  // 형변환 필요 없음!
```

```java
Box<Integer> intBox = new Box<>();
intBox.set(123);
Integer i = intBox.get();
```


---
## Python언어

### boolean타입
언어별로 `boolean`타입 표기를 **대문자**로 하는 언어는 **Python**밖에 없다.


## SQL - DDL

### DDL(Data Define Language, 데이터 정의어)
#### 전체 연관 구조 정리
```css
[SCHEMA]
 └── [TABLE] ← [DOMAIN] 사용 가능
       └── [INDEX] 적용 가능
       └── [VIEW]는 테이블을 참조하여 정의됨
```

|요소|역할|예시 관계|
|---|---|---|
|SCHEMA|모든 객체를 담는 공간 (최상위)|테이블, 뷰, 인덱스가 스키마 안에 포함됨|
|DOMAIN|컬럼의 데이터 형식 및 제약조건 정의|테이블의 컬럼에서 사용됨|
|TABLE|데이터를 저장하는 구조체|뷰와 인덱스가 이 테이블 기반으로 생성됨|
|VIEW|테이블을 참조하는 가상 테이블|SELECT 쿼리 결과를 테이블처럼 보여줌|
|INDEX|테이블 검색 성능을 향상시키는 도구|테이블 컬럼에 대해 생성됨|


### 키 개념
#### ✅ 1. 기본키 (Primary Key)

- **각 행(row)을 유일하게 식별할 수 있는 키**야.
    
- **중복되면 안 되고(NULL도 안 돼)**, 테이블에서 반드시 **하나만 존재**해야 해.

``` sql
CREATE TABLE student (
	student_id INT PRIMARY KEY,  -- 기본키
	name VARCHAR(50),
	age INT
);
```
📌 예: `주민등록번호`, `학번`, `제품코드` 등  
→ **절대 겹치지 않는 식별자**를 기본키로 설정해.

---

#### ✅ 2. 대체키 (Alternate Key)

- **기본키 후보들 중에서 선택되지 않은 나머지 키**야.
    
- 즉, 기본키가 될 수 있었지만 **선택받지 못한 키들**이야.

``` sql
-- 예시
학번 (기본키 후보)
주민등록번호 (기본키 후보)

→ 학번을 기본키로 선택하면, 주민등록번호는 **대체키**
```

📌 의미: 기본키처럼 **유일성은 있지만**, 실제로 기본키로 **채택되지 않은 키**를 말해.

---

#### ✅ 3. 외래키 (Foreign Key)

- **다른 테이블의 기본키를 참조하는 키**야.
    
- 두 테이블을 **연결(관계)**할 때 사용해.

``` sql
CREATE TABLE course (
	course_id INT PRIMARY KEY,
	course_name VARCHAR(50),
	student_id INT,
	FOREIGN KEY (student_id) REFERENCES student(student_id)
);
```

📌 설명: `course` 테이블에서 `student_id`는 `student` 테이블의 `student_id`를 참조함 → 외래키!

→ 외래키는 **참조 무결성(Integrity)**을 지켜주는 역할을 해.

---

#### 📌 세 가지 키 정리 표

|키 종류|설명|특징|
|---|---|---|
|기본키(PK)|각 행을 유일하게 식별하는 키|중복 ❌, NULL ❌, 1개만 가능|
|대체키(AK)|기본키 후보 중, 선택되지 않은 키|중복 ❌, NULL ❌|
|외래키(FK)|다른 테이블의 기본키를 참조하는 키|중복 ⭕, NULL ⭕ (제약에 따라 다름)|

---

#### 🔄 관계 예시
``` text
[학생 테이블]
학번(PK), 이름, 주민등록번호(AK)

[수강 테이블]
수강번호(PK), 강의명, 학번(FK)
```

- **학번**은 `학생 테이블`에서 기본키(PK)
    
- **주민등록번호**는 대체키(AK)
    
- `수강 테이블`에서 학번은 외래키(FK)


## DML - SELECT - 2
SELECT문에서 실행 순서는 아래와 같다.

1. FROM
2. WHERE
3. GROUP BY
4. HAVING
5. SELECT
6. ORDER BY

**1. FROM**
데이터를 가져올 테이블을 선택한다.
`전체 행 컬럼이 다 있는 상태`

**2. WHERE**
행 하나하나를 검사해서 가져올 행들을 필터링한다.
`그룹을 만들기 전의 개별 행 필터`

**3. GROUP BY**
남은 행들을 그룹별로 묶는다.
`하나의 속성에 따라서 행들을 그룹으로 묶어둔다`

**4. HAVING**
그룹 바이 절에서 만든 그룹에서 해당 그룹의 조건을 검사한다.
`그룹에 대한 조건 검사`

**5. SELECT**
조건을 통과한 그룹에서 가져올 데이터를 출력한다.


#### 상여금 예시
##### ① `FROM 상여금`

- `상여금`이라는 테이블에서 데이터를 가져와.
    
- 이 시점에는 **전체 행 전체 컬럼이 다 있는 상태**야.
    

---

##### ② `WHERE 상여금 >= 100`

- **행 하나하나를 검사해서**, `상여금` 값이 **100 이상인 행만 남겨**.
    
- **그룹을 만들기 전에 먼저 필터링**을 하는 단계야.
    

🧠 `WHERE`은 **그룹을 만들기 전의 개별 행 필터**라고 꼭 기억해!

---

##### ③ `GROUP BY 부서`

- 이제 남은 행들을 **부서별로 묶어**.
    
- 즉, 부서가 같은 행들끼리 **그룹(묶음)**을 만든다.
    

예:

```makefile
부서: 영업
 → 사람 1, 사람 2, 사람 3

부서: 총무
 → 사람 4, 사람 5
```

---

##### ④ `HAVING COUNT(*) >= 2`

- 위에서 만든 그룹(부서별 묶음) 중에서,  
    **해당 그룹의 조건을 검사해**.
    
- 여기서는 `COUNT(*) >= 2`,  
    즉, **해당 부서에 2명 이상이 상여금 100 이상을 받았는지** 검사.
    

🧠 `HAVING`은 **그룹에 대한 조건**이야.  
`WHERE`과는 다르게, **그룹 함수(COUNT, SUM 등)를 쓸 수 있어**.

---

##### ⑤ `SELECT 부서, COUNT(*) AS 사원수`

- 이제 조건을 통과한 그룹들에서  
    `부서` 이름과 `COUNT(*)` 값을 출력해.
    
- `COUNT(*)`는 해당 그룹(부서) 안에 **조건을 통과한 행의 개수**야.
    
- `AS 사원수` → 결과 컬럼 이름을 **'사원수'**라고 표시해줘.
####

### JOIN

#### 요약표 (정리용)

|JOIN 종류|키워드/구조|특징|
|---|---|---|
|INNER JOIN|`INNER JOIN ... ON`|공통 행만|
|LEFT JOIN|`LEFT JOIN ... ON`|왼쪽 모두 + 매칭|
|RIGHT JOIN|`RIGHT JOIN ... ON`|오른쪽 모두 + 매칭|
|FULL JOIN|`FULL OUTER JOIN ... ON`|양쪽 모두|
|CROSS JOIN|`CROSS JOIN`|곱집합|
|SELF JOIN|자기 자신과 조인|자기 비교|
|NATURAL JOIN|`NATURAL JOIN`|자동 연결|
|EQUI JOIN|`WHERE A.x = B.x`|`=` 조건 조인|
|NON-EQUI JOIN|`WHERE A.x < B.x` 등|범위 조건 조인|


## 인터넷
> 인터넷이란 ? **TCP/IP 프로토콜**을 기반으로 **전 세계 수많은 컴퓨터와 네트워크들이 연결된 광범위한 컴퓨터 통신망**

### TCP/IP 프로토콜이란 ?
컴퓨터끼리 **인터넷에서 데이터를 주고받기 위한 프로토콜**이며 크게 **4계층**구조로 이루어져 있다.

|계층|역할|주요 프로토콜|
|---|---|---|
|**응용 계층**|사용자 앱 간의 통신|HTTP, FTP, SMTP 등|
|**전송 계층**|앱 간 데이터 전달 보장|**TCP**, **UDP**|
|**인터넷 계층**|컴퓨터 간 주소 지정 및 경로 설정|**IP**, ARP, ICMP|
|**네트워크 인터페이스 계층**|실제 물리적인 데이터 전송|이더넷, Wi-Fi 등|

**웹페이지를 여는 예시를 통해 살펴보자**
1. 크롬에서 주소 입력 → **HTTP 요청 발생 (응용 계층)**
2. 데이터를 **TCP**가 쪼개고 순서 정함 (전송 계층)
3. **IP**가 목적지 주소 붙임 (인터넷 계층)
4. 실제 신호가 케이블이나 와이파이 통해 전송됨 (인터페이스 계층)

### 그래서 IP가 뭐야 ?
> 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소

- 8비트(1바이트)씩, 총 32비트로 구성되어 있다.
- IP주소는 네트워크 부분의 길이에 따라 다음과 같이 A 클래스에서 E 클래스까지 총 5단계로 구성되어 있다.

**네트워크 주소**
> 이 IP가 **어느 네트워크(동네, 회사)** 에 속해 있는지 나타냄

**호스트 주소**
> 해당 네트워크 안에서 **어떤 장비(PC, 프린터 등)**인지 나타냄

**IP 주소** = 네트워크 주소 + 호스트 주소

**브로드 캐스트 주소**
> **하나의 네트워크 안에 있는 모든 장비(호스트)에게 한꺼번에 메시지를 보내는 주소**.

브로드캐스트 주소가   `192.168.0.255`와 같다면,
- `255`는 해당 네트워크의 **호스트 주소 영역에서 가장 큰 값**
- **이 주소로 보내면 네트워크에 있는 모든 장비가 받는다**

### 서브네팅
> 하나의 IP 네트워크를 **여러 개의 작은 네트워크(서브넷)** 로 나누는 기술  
> 네트워크 자원을 **효율적으로 관리**하고, **브로드캐스트 범위**를 줄일 수 있음

- 기존의 네트워크 주소에서 **호스트 비트를 일부 빌려** 서브넷 구분자로 사용
- 결과적으로 **서브넷 개수는 늘고**, **각 서브넷의 호스트 수는 줄어듦**

#### 서브넷 마스크
> IP 주소에서 **네트워크 주소와 호스트 주소를 구분**하기 위한 32비트 값을 **서브넷 마스크**라고 하며, 이를 변경하여 네트워크 주소를 여러 개로 분할하여 사용한다.

- **1은 네트워크**, **0은 호스트**
- 예: `255.255.255.0` = `11111111.11111111.11111111.00000000`

#### 서브네팅 예시
**예제**
- IP: `192.168.1.0/24` (기본 C클래스)
- 서브네팅 목표: 각 서브넷에 **최대 30대 장비**

**풀이**
1. 필요한 호스트 수: 30 + 2(네트워크 & 브로드캐스트) = 32
    
2. `2^5 = 32` → 호스트 비트 5개 필요 → 네트워크 비트 27개
    
3. 결과: `/27` 서브넷 마스크 = `255.255.255.224`

#### 문제 예제
> 200.1.1.0/24 네트워크를 FLSM 방식을 이용하여 10개의 Subnet으로 나누고, ip subnet-zero를 적용했다. 이때 서브네팅된 네트워크 중 10번째 네트워크의 broadcast IP 주소를 쓰시오.

**FLSM(Fixed Length Subnet Mask)**
- 하나의 네트워크를 **같은 크기의 서브넷들로 일정하게 나누는 방식**
- **모든 서브넷의 호스트 수가 동일**

##### 1. FLSM 방식에서 필요한 비트 수 계산
**/24** → 기본적으로 **256개 IP 주소** 존재
**10개 서브넷** 필요 → 몇 개 비트 더 빌려야 할까?

> `2^n >= 10` 이 되는 최소 `n`을 찾기

- `2^3 = 8` **X**
    
- `2^4 = 16` **O**

즉, **4비트를 추가로 네트워크에 사용**

→ 새 서브넷 마스크 = `/24 + 4 = /28` 
-> `/28`은 1이 28개이므로 2진수로 `11111111.11111111.11111111.11110000`다. 
→ 10진수로 바꾸면 서브넷 마스크 = `255.255.255.240`

##### 2. /28에서 각 서브넷당 주소 범위
/28은 **호스트 비트가 4개** →  `2^4 = 16개 주소` → 이 중 14개가 **사용 가능**
→ 하나의 서브넷은 **16개 단위로 증가**

첫 서브넷의 네트워크 주소는 200.1.1.0이므로,
해당 서브넷의 가장 큰 값인 브로드캐스트 주소는 200.1.1.15이다. 

16씩 증가하므로 10번 째 서브넷의 브로드캐스트 주소는 `200.1.1.159`


## 문자열 저장 방식
**Java에서의 저장 방식은 c언어와 python모두 동일해 ?**

좋은 질문이야!  
Java에서의 **문자열 저장 방식(String Constant Pool)**은  
**C언어와 Python에서는 다르게 동작**해.  
각 언어의 문자열 저장 방식 차이를 자세히 비교해줄게.

---

## ✅ 1. Java

- `"A"` 같은 **문자열 리터럴은 String Constant Pool(상수 풀)**에 저장
    
- **동일한 리터럴은 하나의 객체를 공유**
    
- `==`는 **주소(참조)** 비교 → 리터럴끼리는 true일 수도 있음
    
- `.equals()`는 **값 비교**
    

``` java
String a = "hello"; String b = "hello";
System.out.println(a == b);        // true System.out.println(a.equals(b));   // true
```

---

## ✅ 2. C 언어

- `"hello"` 같은 **문자열 리터럴은 read-only 메모리 영역**(텍스트 영역)에 저장됨
    
- **컴파일러가 최적화해서 같은 리터럴은 재사용할 수도 있음** (컴파일러 구현 따라 다름)
    
- `==`는 **주소(포인터)** 비교
    
``` java
char *a = "hello"; char *b = "hello";
printf("%d\n", a == b); // 보통은 1 (같은 주소), 하지만 구현마다 다름
```

💡 단, 아래와 같은 경우는 다름:
``` c
char a[] = "hello";// 배열에 복사됨 → 새로운 메모리
char b[] = "hello"; printf("%d\n", a == b);  // false
```

- `char*`은 문자열 리터럴 주소를 가리킴
    
- `char[]`는 배열이어서 별도의 메모리 공간에 문자열 복사
    

---

## ✅ 3. Python

- `"hello"` 같은 문자열은 **immutable(불변)** 객체
    
- Python도 **같은 리터럴은 내부적으로 캐싱**해서 **객체를 재사용**할 수 있음
    
- `==`는 **값 비교**, `is`는 **주소(객체 동일성)** 비교
    

``` python
a = "hello"
b = "hello"
print(a == b) # True
print(a is b)  # True (리터럴 캐싱 덕분)
```

💡 하지만, 일부 긴 문자열이나 동적으로 만들어진 문자열은 `is`가 `False`일 수도 있어
``` python
a = "hello world, this is python!"
b = "hello world, this is python!"
print(a == b)  # True
print(a is b)  # False (다를 수 있음)
```

---

## ✅ 요약 비교표

|항목|Java|C 언어|Python|
|---|---|---|---|
|문자열 저장|상수 풀 (String Pool)|읽기 전용 메모리(RoData 등)|Heap(불변객체, 캐싱 가능)|
|리터럴 재사용|✅ 항상|⚠️ 컴파일러 구현 따라 다름|✅ 보통 재사용 (캐시)|
|`==` 의미|참조(주소) 비교|주소 비교 (포인터)|값 비교 (`is`는 주소 비교)|
|값 비교|`.equals()` 사용|`strcmp()` 사용|`==` 연산자|

---

### 💡 결론

- **Java**는 상수 풀에서 리터럴을 **자동 공유**
    
- **C**는 컴파일러에 따라 같을 수도, 다를 수도 있음
    
- **Python**은 내부적으로 캐싱하지만, 항상 보장되진 않음  
    → `==`로 비교는 OK, `is`는 조심!