**과목별 기출 풀기 - 오답 정리 - 모르는 문제 기출 풀이에서 참고**

## 소프트웨어 설계 (1과목) 

**전체적인 소프트웨어 개발 과정**
계획 -> 분석 -> 설계 -> 구현 -> Test
(5과목)         (1과목)                (2과목)

**요구사항 개발 프로세스**
도출 -> 분석 -> 명세 -> 확인

#### 객체지향
**객체지향 특징**
- 캡슐화(Encapsulation)
- 정보은닉(Information Hiding)
- 상속(Inheritance)
- 다형성(Polymorphism)
	- 오버로딩: 같은 메서드를 만드는데, 인자의 개수만 다르다
	- 오버라이딩: 상속받는 경우 메서드를 재정의
- 추상화(Abstraction)
	- 깡통을 만들고, 그 깡통을 상속받아서 그 기능들을 구현해라

하향식 설계 -> 구조적, 절차적
상향식 설계 -> 객체지향

#### 자료 흐름도(DFD)
![[Pasted image 20250504183057.png]]
DFD와 관련이 높은건 **D.D(Data Dictionary)**이다.
- 흘러가는 데이터에서 상세하게 만드는 것.

#### 모델
![[Pasted image 20250504183417.png]]
소프트웨어 개발이란 구현 단계를 의미한다.
개발할때 **모델**은 분석, 설계 단계에서 만들어지고, 해당 단계는 그림을 만드는 과정이다. 즉, **모델**이란 개발을 하기 위해 필요한 그림이다.

#### UML(Unified Modeling Language)
> **UML (통합 모델링 언어, Unified Modeling Language)** 은  
> **소프트웨어 시스템을 시각적으로 표현하기 위한 표준화된 모델링 언어**.

즉,
복잡한 소프트웨어 구조를 **도형(다이어그램)** 으로 표현해서  
개발자, 기획자, 설계자 모두가 **같은 그림을 보고 이해**할 수 있게 해주는 도구이다.

##### 왜 UML이 필요할까?
- 소프트웨어가 복잡해질수록 **설계도(blueprint)** 가 필요
- UML은 **객체지향 설계(OOP)** 에 적합한 **표준 언어**
- 사람마다 다른 방식 대신 **공통된 표현 방법**을 사용해서 **혼란을 줄임**

![[Pasted image 20250504183651.png]]
나머지 3개는 구현 언어이고 각각 Java(객체지향), C(절차지향), Python(객체지향)이다. 모델은 곧 그림을 의미하므로, 모델링 언어란 그림을 그리는 언어에 해당한다.

##### UML 다이어그램
>UML 다이어그램은 총 14개가 있고, **시간에 따른 변화**를 기준으로 **두 가지**로 분류할 수 있다.

>**구조적 다이어그램(Structural Diagram)** 정적인 것
![[Pasted image 20250504190113.png]]
- 시스템의 **구조**를 나타냄
    
- **시간의 흐름과는 무관**
    
- 소프트웨어가 **어떻게 구성되어 있는지** 보여줌

**UML구조적 다이어그램 종류**
- **클배객패컴컴** 클로즈베타 객체패키지 컴컴(와라)


> **행위 다이어그램(Behavioral)** 뭔가 움직이는 것
![[Pasted image 20250504190244.png]]
- **시스템의 동작, 흐름, 상호작용**을 표현
    
- **시간에 따른 변화나 트리거된 이벤트** 중심

**UML 행위 다이어그램 종류**
- **유타상활시커상** 유타상의 활 시커멓상

**유스케이스 다이어그램**
>Actor가 어떻게 움직이고 어떤 기능을 수행할건지
![[Pasted image 20250505151155.png]]

**구성 요소**
- 시스템: 개발하고자 하는 소프트웨어
- 액터: 시스템 외부에서 시스템과 상호작용하는 객체(사람,회사, 외부시스템)
- 유스케이스: 일련의 작업을 수행하기 위한 행위
- 관계: 2개의 액터 또는 유스케이스들이 서로 상호작용함을 나타냄

**유스케이스 다이어그램 관계**
- 연관 관계 (Association)
- 포함 관계 (Include)
- 확장 관계 (Extend) `<< >>`
- 일반화 관계 (Generalization)


#### UI
![[Pasted image 20250504184015.png]]
**유스케이스 :** 유저가 어떤 행동을 할 지 그림으로 그려놓은 것

![[Pasted image 20250504191245.png]]

#### 애자일
![[Pasted image 20250504184234.png]]
애자일 기법 중 XP, 스크럼, FDD는 자주 출제된다.

**XP**의 **핵심 가치** 5가지
**의**자에 **피존** **용**기가 **단**정하게 있다.
`실천사항 12가지는 필기 정리내용 참고`

#### 스크럼
스프린트라는 짧은 단위(보름 ~ 한달) 내에 실행 가능한 소프트웨어가 만들어져야 한다.
매일 15분의 짧은 회의가 이루어짐.

#### 디자인 패턴
>이렇게 하면 **효율적**으로 만들 수 있어 라고 제시하는 샘플코드 같은거

**디자인 패턴의 구성**
- 패턴 이름 및 유형
- 문제 및 배경
- 해결 방안
- 샤례
- 결과
- 샘플코드

##### GOF 디자인 패턴
**생성**, **구조**, **행위** 세 가지 패턴이 있다.

**생성 패턴**
>Factory method, Singleton, Abstract factory,  Builder, Prototype

**구조 패턴**
>Adaptor, Bridge, Composite, Decorator, Facade, Fly weight, Proxy

**행위 패턴**
>Template method, Interpreter, Iterator, Command, Chain of Responsibility, State, Strategy, Mediator, Memento, Visitor, Observer

#### 아키텍처
**아키텍처 = 시스템의 설계도(Blueprint)**

>아키텍처는 **두 가지**가 있다.
>**시스템 아키텍처**
	장비의 전체적인 구성도
 >**소프트웨어 아키텍처**
	소프트웨어의 전체적인 구성도

##### 아키텍처 패턴
- **파이프 필터 패턴**
	- 시스템 처리 결과물을 파이프를 통해 전달받아 처리하고그 결과물을 파이프를 통해 다음 시스템으로 넘겨주는 패턴
	- 입력 -> 처리 -> 반환의 과정을 **반복**
- **클라이언트-서버 패턴**
	- 클라이언트가 서버에 요청을 하고 응답을 받음
- **마스터 슬레이브 패턴**
	- 동일한 구조의 슬레이브 컴포넌트들이 작업을 분할 수행

**클라이언트 서버 시스템과 마스터 슬레이브 패턴의 차이점**
- 클라이언트 서버 시스템처럼 서버 아래에 클라이언트들이 존재하는 것처럼, 마스터가 있고 슬레이브들이 아래에 존재.

- 단, **클라이언트**들은 처리를 할 수 있는 반면 **슬레이브**들은 연산을 안하고 데이터만 받고 넘겨서 **마스터가 모든 처리**을 함



#### 객체지향 분석
![[Pasted image 20250504191444.png]]


#### 인터페이스
**서로 두 시스템을 연결해주는 것**

| 문맥      | 연결 대상        | 인터페이스의 의미      |
| ------- | ------------ | -------------- |
| 소프트웨어공학 | 모듈 ↔ 모듈      | 기능 명세 및 호출 규칙  |
| 시스템구조   | 장치 ↔ 장치      | 물리적 연결 방식      |
| 운영체제    | 하드웨어 ↔ 소프트웨어 | 제어/사용 방식       |
| HCI     | 사용자 ↔ 시스템    | UI (화면, 명령줄 등) |

##### EAI(Enterprise Application Integration)
**기업 내 각종 애플리케이션 및 플랫폼 간 정보 전달, 연계 통합 등 상호 연동이 가능하게 해주는 솔루션**

**목적**
- 다양한 시스템 간 데이터 통합, 업무 자동화

**구성 요소**
- Adapter(외부 시스템과 연결 담당)
- Broker(데이터 변환 및 라우팅)
- Workflow(비즈니스 로직 흐름 정의)
- Manager(모니터링, 관리)

**연동 방식**
- Point-to-Point (1:1 직접 연결)
- Hub & Spoke (중앙 허브를 통해 연결)
- Message Bus (메시지 기반으로 느슨하게 연결)
- Hybrid (여러 방식을 조합한 형태)

#### 미들웨어
##### 미들웨어의 종류
![[Pasted image 20250504215058.png]]


##### 메시지 지향 미들웨어(MOM)
작업할게 엄청 많으면, 그걸 바로 처리하는 것이 아니라 한 곳에 쌓아두고 나중에 처리하는 것을 **메시지 지향 미들웨어**라고 한다.

- **비동기** 방식으로 작동
- 큐 자료구조에 쌓는다

#### CASE(Computer-Aided-Software-Engineering)
**소프트웨어 개발**(Software Enginerring)을 할 때 도움을 주는 모든 것들을 **CASE도구**라고 한다.
`ex) 개발 툴, IDE환경, 협업 도구`

---

## 소프트웨어 개발 (2과목) 

#### 소스코드 품질 분석
**동료 검토(Peer Review)**
- 2~3명이 진행하는 리뷰 형태
- 작성자가 코드를 설명하고 이해 관계자가 들으면서 결함을 발견하는 형태로 진행하는 기법

**워크 스루(Walkthrough)**
- 팀 회의 형태
- 검토 자료를 회의 전에 배포해서 사전검토 한 후 짧은 시간동안 회의를 진행하는 형태

**인스펙션(Inspection)**
- 공식적 검사 회의
- 작업자 외 다른 전문자가 검사하는 가장 공식적인 리뷰 기법
- **계획 -> 사전 교육 -> 준비 -> 인스펙션 회의 -> 수정 -> 후속조치**의 순서로 진행된다.

품질 분석을 통해서 결과적으로 **리팩토링**을 진행.

##### 소스코드 품질 분석 도구
**정적 분석 도구**
- pmd
- cppcheck
- SonarQube
- checkstyle
- ccm
- cobertura

**동적 분석 도구**
- Avalanche
- Valgrind

#### 형상관리
소프트웨어 개발 과정에서 발생하는 **모든 변경**을 관리하는 활동

- 협업을 진행하는 멤버들의 공유 및 변경 이력 관리
- 소스코드, 각종 설계 문서, 회의록 등의 모든 문서가 형상관리 대상
- **형상 관리 도구**
	- 중앙 집중형: CVS, SVN
	- 분산형: Git

##### 형상관리 절차
- 식별 -> 통제 -> 감사 -> 기록
**식도감기**

##### 형상관리 용어정리
![[Pasted image 20250505183340.png]]

#### 테스트
![[Pasted image 20250505184929.png]]
![[Pasted image 20250505184951.png]]
**Black Box 테스트 종류들 기억**

##### 테스트 오라클 종류
- 참 오라클
- 샘플링 오라클
- 추정 오라클
- 일관성 검사 오라클

##### 테스트 하네스 도구
- 테스트 드라이브
	- 상향식
- 테스트 스텁
	- 하향식
- 테스트 슈트
	- 테스트 하는 것들 모아놓은 것
- 테스트 케이스
	- 각각의 기능의 테스트 케이스
- 테스트 스크립트
	- QA들이 테스트 스크립트를 만들어서 자동화 도구에 던지면 빠르게 진행됨
- 목 오브젝트
	- 생각을 해서 던져주는 모듈

#### DRM(Digital Rights Management)
>DRM이란 ? **디지털 저작권 관리**

![[Pasted image 20250505184658.png]]
- 콘텐츠 암호화 및 키 관리
- 콘텐츠 식별체계 표현
- 라이선스 발급 및 관리
- 정책 관리 기술
- 크랙 방지 기술 

**클리어링 하우스(Clearing House)**
CGV본사 와 같은 개념.
영화 판권을 영화관에 제공해줌.

#### 버블 정렬
버블정렬은 인접한 값을 하나씩 비교해나감.
PASS1이 종료되면 마지막 값은 정렬되어 있으므로 제외
PASS2이 종료되면 마지막 2개 값 제외

**컴파일은 고급 언어 -> 저급 언어 변환**

#### Tree 구조 순회
순회의 이름은 **부모를 기준**으로 결정됨.
**부모(Root)** 노드는 가장 위 노드가 아닌, 자식을 가지고 있는 노드를 의미함.

**선위 순회(PreOrder)**
Root -> Left -> Right
(부모를 가장 먼저 방문)

**중위 순회(InOrder)**
Left -> Root -> Right
(부모를 중간에 방문)

**후위 순회(PostOrder)**
Left -> Right -> Root
(부모를 마지막에 방문)

#### 반정규화(Denormalization) 유형
**중복 테이블을 추가하는 방법**
- 집계 테이블의 추가
- 진행 테이블의 추가
- 특정 부분만을 포함하는 테이블 추가

---

## 데이터베이스 구축 (3과목) 
#### 데이터베이스 설계 과정
**개 -> 논 -> 물**

##### 개념적 설계(정보 모델링, 개념화)
고객의 머릿속에 있는 것을 모두 다 끄집어냄(회원, 게시판, 회원정보 등등)
끄집어낸 정보를 바탕으로 **E-R 다이어그램**을 만들어줌.

##### 논리적설계
위에서 만든 **E-R 다이어그램**을 바탕으로 **정규화** 작업`(위 데이터에는 중복이 있으므로 예쁘게 쪼개는 과정)`을 진행하면서, **트랜잭션 인터페이스를 설계**한다.

##### 물리적 설계
**특정** **DBMS**(오라클, MySQL 등등..)에 집어 넣는다.
물리적으로 하드디스크에 구조를 만들어놓고 성능이 나오지 않으면,
**인덱스**를 걸거나 **클러스터링**작업을 하거나 **파티션** 나누기를 해도 안되면 **반정규화**를 진행한다.


#### 트랜잭션
>하나의 작업 단위 (예: 송금)
- 여러 SQL 문을 **한 덩어리로 묶어 처리**
- 전부 성공하거나, 전부 실패해야 함 (All or Nothing)

##### 트랜잭션의 상태
![[Pasted image 20250510204416.png]]


##### 트랜잭션 특성
- **독**립성 (**I**solation) : 하나의 트랜잭션이 실행되고 있을 때 다른 트랜잭션이 영향을 미치면 안됨
- **일**관성 (**C**onsistency) : 트랜잭션 이후 데이터들이 일관적으로 유지되어야 함
- **영**속성 (**D**urability) : 트랜잭션의 결과는 영구히 보존되어야 한다.
- **원**자성 (**A**tomicity) : 모두 반영되거나(commit) 모두 반영되지 않아야(rollback) 함


**TCL** **(트랜젝션 제어어 Transaction Control Language)**
> 트랜잭션의 실행 결과를 확정하거나 되돌리는 역할
- COMMIT(**확정**): 지금까지 실행한 변경 사항을 DB에 저장
- ROLLBACK(**취소**): 가장 마지막 COMMIT 이후의 변경 사항 되돌림
- SAVEPOINT(**저장점**): 되돌릴 수 있는 **지점(포인트)** 를 설정


#### 반정규화
![[Pasted image 20250509135727.png]]


#### 데이터베이스 언어

##### SQL명령어 모음
**DMC** -> D**D**L, D**M**L, D**C**L (DMC에서 앞 뒤로 DL만 붙여줌)

**DDL (데이터 정의어 Data Define Language)**
>데이터의 구조를 정의, 변경, 삭제
- **CREATE:** 스키마, 도메인, 테이블, 뷰, 인덱스를 **정의**
- **ALTER:** TABLE에 대한 **정의를 변경**
- **DROP:** 스키마, 도메인, 테이블, 뷰, 인덱스를 **삭제**
- **RENAME:** 이름 변경
- **TRUNCATE:** 리모델링(초기화)

**DML (데이터 조작어 Data Manipulation Language)**
>저장된 데이터를 실질적으로 처리
- **SELECT**: 테이블에서 조건에 맞는 **튜플을 검색**
	- **SELECT**의 기본적인 골격![[Pasted image 20250510193128.png]]
- **INSERT:** 테이블에서 새로운 **튜플을 삽입**
- **DELETE:** 테이블에서 조건에 맞는 **튜플을 삭제**
- **UPDATE:** 테이블에서 조건에 맞는 **튜플의 내용을 변경**

**DCL (데이터 제어어 Data Controll Language)**
>데이터의 보안, 무결성, 회복, 병행 수행 제어 등을 정의,
- **GRANT:** 권한 주기 **TO** `username `
- **REVOKE:** 권한 뺐기 **FROM** `username`

#### E-R 다이어그램

**E**ntity-**R**elationship **Diagram**의 줄임말로,
현실세계의 데이터를 **개체(Entity)** 와 **관계(Relationship)** 로 모델링한 다이어그램

데이터베이스를 설계할 때, **어떤 데이터(개체)** 가 있고, 그것들이 **어떻게 연결(관계)** 되는지를 시각적으로 표현한 **개념적 설계 도구**

>회원이상품이라는 객체를 주문하면 주문이라는 관계가 형성되는 것을 E-R 다이어그램으로 표현
>![[Pasted image 20250510150812.png]]


#### 관계대수, 관계해석
>**관계대수는 '어떻게 처리할지'를 절차적으로 기술**,  
>**관계해석은 '무엇을 원하는지'를 조건만으로 기술하는 논리적 방식**

#### 로킹(Locking) 기법
>트랜잭션이 데이터에 접근할 때 충돌을 방지하기 위해 잠금을 거는 병행 제어 기법

**lock 단위 클 때**
화장실이 있다고 할 때 화장실의 입구를 잠궈버리면 다른 사람들이 이용을 못하고, 일 처리(화장실 청소)도 적어진다.
병행성 ⬇️, 오버헤드 ⬇️

**lock 단위 작을 때**
화장실에서 자기가 이용하는 칸만 잠궈버리면, 다른 사람들이 이용할 수 있는 대신, 일 처리가 많아진다.
병행성 ⬆️, 오버헤드 ⬆️

#### 뷰
>물리적인 테이블을 바탕으로 가상의 테이블을 만듬. (외부 스키마)

물리적인 테이블이 사라지면 자동적으로 **뷰**도 사라진다.

뷰는 생성(CREATE)과 삭제(DELETE)만 가능하다.

#### 정규화 과정
![[Pasted image 20250510160621.png]]

**도부이결다조** (두부 이걸 다 줘 ?!)
**1NF = 제1정규형**

#### 스키마
**스키마(Schema)란?**
> **데이터베이스의 구조와 제약조건을 정의한 설계도(도식)**

📌 쉽게 말하면,  
👉 “**데이터베이스에 어떤 테이블이 있고, 어떤 열(속성)을 갖고, 어떤 제약조건이 있는지**”를 **미리 정의한 설계 문서**야.

---
##### 🔸 비유로 쉽게 이해하기

📦 **데이터베이스 = 큰 창고**  
🗂️ **스키마 = 창고 안 물건의 분류 체계 및 설계도**

- 창고에 어떤 선반이 있는지 (테이블)
    
- 선반마다 어떤 물건을 두는지 (속성)
    
- 물건은 어떻게 쌓아야 하는지 (제약조건)

---
##### ✅ 스키마의 3가지 종류 (3단계 스키마)

정보처리기사에서는 **ANSI/SPARC 3단계 스키마 구조**로 자주 출제돼.  
아래 표로 한눈에 정리해줄게.

|스키마 종류|설명|담당자|특징|
|---|---|---|---|
|**외부 스키마**  <br>(External Schema)|사용자(응용프로그램) 입장에서 보는 DB 구조|사용자|뷰(View) 또는 서브 스키마|
|**개념 스키마**  <br>(Conceptual Schema)|조직 전체 관점의 논리적 구조|DBA|DB 전체 구조를 논리적으로 정의 (중심 역할)|
|**내부 스키마**  <br>(Internal Schema)|실제 저장될 물리적 구조|시스템|저장 방식, 인덱스 등 물리적 저장 구조|

##### ✅ 정보처리기사 시험 포인트

- "사용자 관점의 스키마는?" → **외부 스키마**
    
- "DB 전체 구조를 논리적으로 정의하는 스키마는?" → **개념 스키마**
    
- "물리적 저장 구조를 담당하는 스키마는?" → **내부 스키마**

---

##### ✅ 함께 자주 출제되는 개념: **스키마와 인스턴스**

|항목|의미|
|---|---|
|**스키마**|데이터베이스의 구조 정의 (설계도, 고정)|
|**인스턴스**|실제 저장된 데이터 (시점에 따라 변함)|

예: 학생 테이블의 구조 = 스키마  
→ 그 안에 저장된 300명의 학생 데이터 = 인스턴스


#### DBMS
>**Database Management System (데이터베이스 관리 시스템)** 의 줄임말로,  
>데이터베이스를 효율적으로 저장·관리·검색·수정할 수 있게 도와주는 소프트웨어.

**대표적으로** **Oracle**, **MySQL** 등이 있다.


#### 키
![[Pasted image 20250512205530.png]]

## 프로그래밍 언어 활용 (4과목) 

#### UNIX - 쉘(Shell)
> 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기

**실제 사용 예를 들어보자면**
1. 쉘에서 `ls`를 입력하면
2. 쉘이 그걸 **운영체제(커널)에 전달**해서 실행시키고,
3. 해당 디렉토리의 `파일 목록`을 보여준다

시스템과 사용자 간의 **인터페이스**를 담당

하지만, 윈도우의 터미널과는 개념이 다르다.
>**유닉스(Unix)** 운영체제에서 **사용자와 커널 사이를 연결해주는 명령어 해석기**가 바로 **쉘(Shell)** 이다. 
>즉, **Unix 운영체제에서 동작하는 쉘을 통틀어 Unix Shell**이라고 함.


#### UNIX - 커널(Kernel)
>운영체제의 핵심 부분으로, 하드웨어 자원(CPU, 메모리, 입출력 장치 등)을 직접 관리하고 제어하는 소프트웨어

**🔧 사용자와 하드웨어 사이에서 "중재자" 역할**
`사용자 명령 → [쉘] → 커널 → 하드웨어 동작`
- 사용자는 명령어를 쉘에 입력
- **쉘이 커널에게 요청 전달**
- 커널이 실제로 **하드웨어를 제어**
- 작업 결과를 다시 사용자에게 전달

##### 커널이 하는 일 (시험 자주 출제)

| 기능                        | 설명                        |
| ------------------------- | ------------------------- |
| **프로세스 관리**               | 프로그램 실행, 스케줄링, 상태 관리 등    |
| **메모리 관리**                | RAM 배분, 가상 메모리, 메모리 보호 등  |
| **파일 시스템 관리**             | 파일 읽기/쓰기, 디렉터리 관리         |
| **입출력(I/O) 제어**           | 키보드, 디스크, 프린터 등 입출력 장치 제어 |
| **시스템 콜(System Call) 제공** | 사용자 요청을 받아들이는 인터페이스 제공    |

#### OSI(Open Systems Interconnection model)
> **컴퓨터 네트워크에서 데이터가 어떻게 전달되는지**를 계층적으로 나눈 **모델(Model)**

##### OSI 7계층
![[Pasted image 20250510223138.png]]

***데이터 전달 예시***
**응용**, **표현**, **세션** 계층에서 "안녕" 이라는 `데이터`가 나온다.
"안녕"이라는 `데이터`를 **전송 계층**으로 내리면, 데이터 앞에 **헤더(Header)** 를 붙여 `세그먼트`라고 부른다.
`세그먼트`를 **네트워크 계층**으로 내리면 다시 앞에 **헤더(Header)** 를 붙여서 `패킷`이라고 부른다.
`패킷`을 **데이터 링크 계층**으로 내리면 다시 **헤더(Header)** 를 붙여서 `프레임`이라고 부른다.

>`데이터` -> `세그먼트` -> `패킷` -> `프레임`

| 계층 번호 | 계층 이름                    | 주요 역할                        | 암기 키워드    |
| ----- | ------------------------ | ---------------------------- | --------- |
| 7     | **응용 계층** (Application)  | 사용자와 가장 가까운 계층 (예: 브라우저, 메일) | 응 — 사용자   |
| 6     | **표현 계층** (Presentation) | 데이터 형식 변환, 암호화/복호화           | 표 — 변환    |
| 5     | **세션 계층** (Session)      | 연결 유지 및 관리                   | 세 — 연결    |
| 4     | **전송 계층** (Transport)    | 데이터 전송의 신뢰성 보장 (TCP/UDP)     | 전 — 신뢰    |
| 3     | **네트워크 계층** (Network)    | 경로 설정, 주소 지정 (IP 주소)         | 네 — 주소    |
| 2     | **데이터링크 계층** (Data Link) | 프레임 단위 전송, MAC 주소 사용         | 데 — 프레임   |
| 1     | **물리 계층** (Physical)     | 실제 전기/신호/비트 전송               | 물 — 전선/비트 |

###### 계층별 주요 프로토콜/장비 예시

| 계층      | 주요 예시                       |
| ------- | --------------------------- |
| 7 응용    | HTTP, FTP, SMTP             |
| 6 표현    | JPEG, MPEG, 암호화             |
| 5 세션    | NetBIOS, API                |
| 4 전송    | TCP, UDP                    |
| 3 네트워크  | IP, ICMP, **라우터(장비)**       |
| 2 데이터링크 | 이더넷, MAC, **스위치(장비)**       |
| 1 물리    | 전선, **허브(장비)**, **리피터(장비)** |

***시험에 자주 나오는 포인트***
- HTTP는 응용 계층(7계층)
- TCP는 전송 계층(4계층)
- IP는 네트워크 계층(3계층)
- MAC 주소는 데이터링크 계층(2계층)
- 스위치는 데이터링크 계층(2계층) 장비
- 허브는 물리 계층(1계층) 장비
    
- **계층별 역할 구분** & **장비 매칭** 문제 자주 출제!

**ARP:** IP 주소 → MAC 주소 변환
**RARP:** MAC 주소 → IP 주소 변환

##### TCP(Transmission Control Protocol), UDP(User Datagram Protocol)
>TCP와 UDP는 모두 **전송 계층(Transport Layer)** 에서 사용하는  
>**프로토콜(통신 규약)** 이다.

**둘 다 데이터를 보내주는 역할이지만, 전송 방식과 특성이 매우 다르다.**

###### TCP (Transmission Control Protocol)
>📦 신뢰성 보장 + 연결 지향형 통신 방식

***📌 주요 특징***
- **연결형(연결 지향)** 프로토콜  
    → 데이터를 보내기 전에 연결을 먼저 맺음 (3-way handshaking)
    
- **데이터의 순서 보장** (데이터가 순서대로 도착함)
    
- **신뢰성 보장** (손실된 데이터는 재전송)
    
- **속도 느림**, **오버헤드 있음**

***🧠 쓰이는 곳***
- 웹(HTTP), 이메일(SMTP), 파일 전송(FTP) 등  
    → 데이터가 **정확히 전달되는 것이 중요한 곳**


###### UDP (User Datagram Protocol)
> 🚀 **빠르지만 신뢰성 없는**, **비연결형** 통신 방식

***📌 주요 특징***
- **비연결형 프로토콜**  
    → 연결 과정 없이 바로 전송
    
- **데이터 순서 보장 없음**
    
- **신뢰성 보장 안 함** (손실돼도 재전송 안 함)
    
- **속도 빠름**, **오버헤드 적음**

***🧠 쓰이는 곳***
- 스트리밍(동영상, 음성), 온라인 게임, 실시간 통신 등  
    → 약간의 손실은 괜찮고 **속도가 중요한 곳**

##### TCP/IP 4계층
![[Pasted image 20250511174636.png]]

**OSI 7계층**은 **이론적**으로만 존재하는 것이고, **실제로 사용**하는 것은 **TCP/IP 4계층**이다.

오른쪽은 각 계층에서 사용하는 프로토콜

#### 소프트웨어 공학
**3R** `역공학, 재공학, 재사용`을 통해서 유지 보수성을 높여 재개발을 하지 말고 생산성을 높이자.

`재사용`하기 위해서는 **독립성**을 높여야 하므로 **응집도는 높이고**, **결합도는 낮춰야함**

#### CPU 스케줄링 방식
>여러 개의 프로세스가 CPU를 사용하려 할 때,  
>**어떤 프로세스에 CPU를 줄지 결정하는 알고리즘**들의 집합

화장실이 급한 상태에서 안에 싸고 있는 사람을 빼내고 들어가면 **선점형**, 못빼내고 밖에서 기다리면 **비선점형**

##### 선점형 스케줄링
실행 중인 작업도 **중간에 뺏을 수 있음**
- **특징:** 응답성 ↑, 제어 유연함
- **예시**
	- **라운드 로빈** (시간 쪼개서 번갈아가며 처리)
	- **SRTF** (남은 시간 짧은 작업이 끼어듬)
	- **우선순위 스케줄링** (선점형일 경우)
	- **MLQ** 
	- **MFQ**

##### 비선점형 스케줄링
실행 중인 작업은 **끝날 때까지 기다림**
- **특징:** 단순하고 예측 가능
- **예시**
	- **FCFS** (First Come First Serve, 선착순)
	- **SJF(Shortest Job First):** 실행시간 짧은 작업부터 처리
	- **HRN:** `대기시간 + 실행시간 / 실행시간`해서 높은 값 나오는 작업부터 처리

#### 흐름 제어(Flow Control)
>송신 측과 수신 측 간의 데이터 전송 속도 차이 때문에 생길 수 있는 문제를 해결하기 위한 **전송 제어 기법**

**왜 필요할까?**
- 송신자는 빠르게 데이터를 보내는데, 수신자가 느리게 처리하면 데이터가 유실되거나 **오버플로우(버퍼 초과)** 발생할 수 있음.

##### 흐름 제어 주요 방식
**정지-대기(Stop and wait) 방식** 
- 송신자는 한 번에 한 프레임만 보내고, 수신자로부터 **확인 응답(ACK)** 을 받아야 다음 프레임을 전송
- 단순하고 안정적이지만, 속도가 느림

**슬라이딩 윈도우(Sliding Window) 방식**
- 한 번에 여러 개의 프레임을 보내되, **수신 확인(ACK)** 을 윈도우 크기만큼 받고, 그에 따라 창을 밀면서 계속 전송.
- 네트워크 대역폭을 효율적으로 활용

**흐름 제어용 XON/XOFF 프로토콜**
- 문자 기반 흐름 제어
- XOFF: "잠깐 멈춰!" / XON: "계속 보내!"
- 수신자가 송신자에게 문자로 "XOFF/XON"을 신호로 보냄

#### 오류 제어(Error Control)
> 데이터가 전송 중에 손상되거나 누락되는 것을 검출하고 복구하는 기법

**왜 필요할까?**
- 네트워크 통신에서는 전송 중에 전기적 간섭이나 노이즈로 인해 데이터가 **깨지거나 없어질 수 있기 때문에**, **정확한 전송을 보장**하려면 오류 제어가 꼭 필요함.

**주요 역할**
- **오류 검출(Error Detection):** 데이터가 깨졌는지 확인
- **오류 정정(Error Correction):** 깨진 데이터 복구 또는 재전송 요청

##### 오류 제어 주요 방식
**ARQ (Automatic Repeat reQuest) 자동 재전송 요청**
>오류 발생 시, **다시 보내 달라고 요청**하는 방식

- **Stop and wait ARQ**
	프레임 1개 보내고 응답 기다림

- **Go-back-N ARQ**
	오류 발생한 이후 해당 지점부터 프레임들 전부 재전송

- **Selective-Repeat ARQ**
	오류 난 프레임만 선택적으로 재전송

- **적응성(Adaptive) ARQ**

#### 결합도(Coupling)
>하나의 모듈이 다른 모듈에 얼마나 **의존하고** **연결되어 있는지**를 나타내는 **척도**

##### 결합도의 종류
결합도는 강할수록 나쁘고, 약할수록 좋다.

- **내용 결합 (Content Coupling):** 다른 모듈의 내부 기능에 직접 접근 -> 최악
- **공통 결합 (Common Coupling):** 전역 변수를 여러 모듈이 함께 사용
- **외부 결합 (External Coupling):** 모듈 외부의 시스템 요소(파일, DB 등) 에 의존
- **제어 결합 (Control Coupling):** 어떤 모듈이 논리적 제어 정보(플래그 등)를 전달
- **스탬프 결합 (Stamp Coupling):** **필요 이상의 자료구조 전체**를 전달 (예: 구조체 전체)
- **자료 결합 (Data Coupling):** 필요한 데이터만 매개변수로 전달 → 가장 이상적! ✔️

##### 💡 비유로 이해하기
> 📦 모듈 A와 모듈 B가 서로 어떤 방식으로 **물건(데이터)** 을 주고받는다고 생각하자.

- **내용 결합**: A가 B의 집에 몰래 들어가 물건을 바꿈
- **공통 결합**: 같은 창고(전역 변수)를 두고 둘이 막 사용
- **제어 결합**: A가 “이거 받으면 이렇게 행동해!” 하고 명령함
- **자료 결합**: A가 필요한 정보만 정확히 전달하고, 나머지는 간섭 안 함 ← ✅ 이상적

#### 응집도(Cohesion)
> **하나의 모듈 내부의 기능 요소들이 얼마나 밀접하게 관련되어 있는지**를 나타내는 척도

높은 응집도 = **하나의 명확한 기능을 수행, 유지보수 쉬움**

- **우연적 응집 (Coincidental):** 관련 없는 기능들이 그냥 묶여 있음
- **논리적 응집 (Logical):** 유사한 성격의 기능이 논리적으로 묶였지만, 플래그에 따라 동작이 달라짐
- **시간적 응집 (Temporal):** 같은 시간대에 실행되는 작업들이 묶여 있음 (예: 시작 시 초기화)
- **절차적 응집 (Procedural):** 순서에 따라 실행되지만 기능적으로는 관련이 적음
- **통신적 응집 (Communicational):** 동일한 데이터를 사용하는 기능들이 묶여 있음
- **순차적 응집 (Sequential):** 앞 작업의 출력이 다음 작업의 입력이 됨
- **기능적 응집 (Functional):** 오직 하나의 기능만 수행 → 최고 수준의 응집도 ✔️

##### 비유로 이해하기
> 모듈은 **팀**이라고 생각해보자.

- **우연적 응집**: 아무나 모아 놓음 (목적 없음)
- **시간적 응집**: 아침에 출근하는 사람들
- **절차적 응집**: 줄 서는 사람들
- **기능적 응집**: **같은 목표를 위해 협력하는 전문가 팀** ← ✅ 이상적

#### 내부 단편화
> 할당받은 메모리 블록 안에서 실제 사용하지 못하고 낭비되는 공간

##### 💡 예시로 이해하기
- 운영체제가 메모리를 8KB 단위로만 나눠줄 수 있다고 해보자.
    
- 어떤 프로그램이 6KB만 필요해.
    
- 그런데 최소 단위가 8KB니까 8KB를 통째로 줘야 해.

> 👉 이 때, **남는 2KB가 내부 단편화**야!  
> (6KB만 쓰고, 2KB는 못 쓰고 그냥 낭비됨)


#### 외부 단편화
> 메모리를 할당하고 남은 작은 빈 공간들이 여기저기 흩어져 있는 상태
> -> 필요한 크기의 메모리를 연속적으로 할당할 수 없게 됨

##### 💡 예시로 이해
- 메모리 전체에 빈 공간이 100KB씩 세 군데 있음 (총 300KB)
    
- 그런데 연속된 150KB 공간은 없음
    
- 150KB를 요청해도 **"공간 부족" 오류 발생**

> 👉 이럴 때가 **외부 단편화**!  
> 실제로는 공간이 충분하지만, **쪼개져 있어서 못 씀**

#### 메모리 할당 기법

메모리를 **어떻게 나누어 줄까?** 를 결정하는 전략들!

##### 1. 📌 **First-fit (최초 적합)**
> **처음으로 맞는 공간에 할당**  
> → 빠르지만, **초기 부분이 자주 쪼개져 외부 단편화 심화**

##### 2. 📌 **Best-fit (최적 적합)**
> **딱 맞는 가장 작은 공간**에 할당  
> → 공간 활용은 좋지만, **검색 오래 걸림** + **외부 단편화 심함**

##### 3. 📌 **Worst-fit (최악 적합)**
> **가장 큰 공간**에 할당  
> → 큰 공간을 나눠서 쪼개기 때문에 **큰 요청 대응 어려움**

#### 교착상태(Deadlock)
>둘 이상의 프로세스가 서로가 가진 자원을 기다리면서 영원히 끝나지 않고 멈춰있는 상태

##### 💡 비유로 쉽게 이해하기
> 두 사람이 식사 중인데,  
> 한 사람은 **포크를 잡고 나이프를 기다리고**,  
> 다른 사람은 **나이프를 잡고 포크를 기다려.**

→ 서로 상대방이 가진 걸 기다리기 때문에 **영원히 식사를 못 해.**  
👉 이게 **교착상태야.**

##### 교착상태 발생 조건 (4가지)
> 교착상태는 아래 4가지 조건이 **모두 만족**할 때 발생한다
> -> 하나라도 깨면 **예방 또는 회피**할 수 있다.

- **상호 배제(Mutual Exclusion):** 자원은 한 번에 하나의 프로세스만 사용할 수 있음
- **점유와 대기(Hold and Wait):** 자원을 가지고 있으면서, 다른 자원을 기다림
- **비선점(Non-preemption):** 자원을 강제로 뺏을 수 없음
- **환형 대기(Circular Wait):** 각 프로세스가 다음 자원을 기다리며 원형으로 연결됨

#### IPv4, IPv6 비교
![[Pasted image 20250511210336.png]]
![[Pasted image 20250511210359.png]]

**IPv4**는 U.M.B = 4B 연필
**IPv6**는 U.M.A

#### 스래싱(Thrashing) 현상
>**CPU(프로세서)** 가 메모리에 올라와있는 **작업(프로세스)** 을 처리하는 일보다, 메모리가 꽉차서 하드 디스크에서 **작업을 올렸다가 내렸다가(페이지 참조)** 에 자원을 더 소모하는 경우를 얘기한다.
>**-> 그래서 CPU 성능이 떨어짐**

![[Pasted image 20250511211846.png]]



#### 프레임워크(Framework)
>**기본 틀(구조)** 을 제공하고,  
 >그 안에서 **개발자가 필요한 부분만 채워 넣는 방식**.

- 건축으로 비유하면: **건물 뼈대**는 정해져 있고,  
    개발자는 **내부 인테리어만 꾸미는 느낌**.
    
- ex) Spring, Django, Angular

🟡 **특징:**

> 프레임워크가 개발자의 코드를 **제어(제어의 역전, IoC)**함.

#### 라이브러리(Library)
> 자주 쓰는 기능들을 **미리 구현해 둔 코드 묶음**  
> → **필요한 함수만 골라서 호출**해 사용.

- 건축으로 비유하면: **가구나 공구 세트**  
    → 개발자가 원하는 도구를 직접 꺼내 씀.
    
- ex) jQuery, NumPy, Lodash

🟡 **특징:**

> **개발자가 직접 호출해서 사용**함. (개발자가 주도)

#### API(Application Programming Interface)
> **완제품(소프트웨어)** 이 있으면 해당 완제품의 기능을 **호출해서 쓸 수 있게 해주는 연결 통로**

- 쉽게 말해: **"사용설명서"** 또는 **"규칙"**
    
- ex) Google Maps API, OpenWeather API

🟡 **특징:**

> 어떤 프로그램이 **다른 프로그램의 기능을 쓰는 방법**을 정의한 문서 또는 명세




---
## 정보시스템 구축 관리 (5과목)

#### 취약점 관리
**관리적 보안**
>정보보호, 인적보안, 업무 연속성 관리 등 정의

**물리적 보안**
>건물 및 사무실 통제, 전산실 관리 지침, 정보 시스템 보호 설치 및 관리, 재해 복구 센터 운영 등의 정의

**기술적 보안**
>사용자 인증, 접근 제어, PC, 서버, 네트워크, 데이터(DB) 등 보안 지침 정의


#### Dos(Denial of Service) 공격
>서비스 거부 공격

##### DDos 공격
>**여러 대의 컴퓨터(좀비 PC)**를 이용해 **동시에 대량의 요청을 보내는 DoS 공격**

![[Pasted image 20250512005241.png]]

![[Pasted image 20250512005254.png]]


#### 암호 알고리즘

**대칭 암호 알고리즘**
> 빠르고 많은 양

편지를 전달하는애한테 키를 전달해줌. 그럼 영희한테 전달해주면서 상자를 열어볼 수 있음

**비대칭 암호 알고리즘**
> 느리고 적은 양

상자를 열 수 있는 키를 영희의 개인 키(공개 키)로 암호화시킴. 키는 적은 양이기 때문에 암호화해도 괜찮음.

![[Pasted image 20250512005723.png]]

#### 단방향
암호화가 가능하지만, 복호화가 불가능

**HASH**
레인보우 테이블, 브루트 포스로 깰 수 있기 때문에 salt로 양념을 침.