## 터미널

### 터미널 명령어
- ~ : 홈 디렉토리 표시
- <명령어> --help : 해당 명령어에 대한 설명과 flag를 알려줌 (man과 같은 역할)
- cd (폴더) : 해당 디렉토리로 위치 이동
- cd .. : 뒤로 돌아가기
- cd / : /위치로 이동
- cd ~ : 홈 위치로 이동
- ls : 리스트 나열
	- ls -l : 리스트 상세정보 표시
- mkdir : 디렉토리 생성
- touch : 확장자 붙여서 파일 생성 가능 (이미 있는 파일일 경우 파일에 접근)
- rm : 파일 제거 (바로 영구삭제 되므로 주의)
	- rm -rf : 어떤 파일이고 안에 뭐가 들어있든 제거
- rmdir : 빈 디렉토리 제거
- node : node.js 실행
	- node (파일) : 노트js를 통해 파일 실행

## Node Js
- **자바스크립트를 브라우저 외부에서 실행시킬 수 있게 해주는 도구**

**form 태그에서 action의 역할**
- 요청을 action의 url로 전송
### req
**req.params**
- req.params는 URL경로에서 콜론(:)으로 시작하는 값을 정의함.
- ex) /products/:id에서 req.parms => id값 반환
**req.query**
- URL경로에서 ?이후로 오는 키-값 쌍의 값을 반환함.
- ex) /products?name=cheese에서 req.query.name => cheese반환
**req.body**
- JSON등의 바디 데이터를 담을 때 사용한다.
- 주로 POST로 유저의 정보 또는 파일 업로드를 보냈을 때 사용
- 요청 본문에 제출 된 키-값 데이터 쌍을 포함한다.
- `app.use(express.urlencoded({ extended: true }))` req.body 파싱하게 해주는 코드 
### **res**
**res.locals**
- 전역변수 같은 느낌 어플리케이션 레벨에서 설정한 변수를 ejs파일에서 쓸 수 있음.
	![[첨부 파일 소스/Image File 1/Pasted image 20240217114655.png]]
	![[첨부 파일 소스/Image File 1/Pasted image 20240217114709.png]]
- app.js 에서 선언하고 boilerPlate.ejs 에서 불러오기 

**라우터 축약**
STEP 1
![[첨부 파일 소스/Image File 1/Pasted image 20240220174730.png]]
![[첨부 파일 소스/Image File 1/Pasted image 20240220174753.png]]
- 라우터의 미들웨어를 컨트롤러 파일에 모아두고 거기서 가져옴.

 STEP 2 ![[첨부 파일 소스/Image File 1/Pasted image 20240220175428.png]]
 - 경로가 같은 라우터끼리 묶어줌.


## 모듈과 NPM

**노드 모듈 작동 방식**
![[첨부 파일 소스/Image File 1/Pasted image 20240201115953.png]]
- 파일안에 모듈을 만들고 exports를 통해 내보내기

![[첨부 파일 소스/Image File 1/Pasted image 20240201114207.png]]
- require를 통해 호출하면 객체가 반환된다.

node_modules는 용량을 많이 차지해 대부분의 패키지에서 포함 X
터미널에서 npm i 를 실행하면 package.json의 디펜던시 목록에 있는 패키지들을 자동으로 설치.

npm init을 통해 package.json 설치 가능. (뒤에 -y붙이면 질문 스킵)
### NPM 패키지

- **UUID** : 불규칙한 ID코드 생성해줌
- **method-override** : form요청을 get,post 두 개가 아닌 다른 메서드 사용 가능.
- **morgan** : HTTP요청 정보(ex.로딩시간)를 터미널에 로그로 남겨줌.
- **ejs-mate** : layout같은 boilerplate 만들어줌.
- **joi** : Schema유효성 검사해줌 joi에서 사용하는 schema는 mongoose의 스키마와는 다른 개념이다. mongoose의 스키마는 타입을 지정하는 것이고 joi의 스키마는 설정해둔 타입과 입력된 타입이 일치하는지 유효성 검사를 할 때 사용되는 것이다.
- **cookie-parser** : Express밖에서 쿠키를 읽기 위해 필요함.
- **express-session** : 세션 설정
- **connet-flash** : 환영 메시지나 가입 축하 메시지 등의 플래시 메시지 띄움
- **bcrypt** : 비밀번호 암호화시켜주는 해시함수
- **passport** : 사용자 인증 자동 생성  ![[첨부 파일 소스/Image File 1/Pasted image 20240219093709.png]]
- **multer** : 주로 파일 업로드 할 때 파일의 데이터를 파싱해주는 미들웨이
- **cloudinary** : 업로드한 파일 저장해줌.
- **dotenv** : api키 같이 보안이 필요한 파일을 키-값 쌍으로 해서 저장해주는 패키지.
- **multer-storage-cloudinary** : multer로 파싱한 파일을 cloudinary에 업로드해주는 패키지. 
## Express

- Node.js를 위한 빠르고 쉬운 웹 프레임워크
- 서버를 만들고, 라우팅을 돕고, 미들웨어를 추가할 수 있게 해준다. 
- Express는 기본적으로 일련의 미들웨어 함수 호출이다.

- **[라우트(Route)](https://ko.wikipedia.org/wiki/%EB%9D%BC%EC%9A%B0%ED%8A%B8)** : 경로, 서로 다른 네트워크 간 데이터를 전송하고 전송한데이터를 받는 경로를 말한다.
- **[라우터(Router)](https://ko.wikipedia.org/wiki/%EB%9D%BC%EC%9A%B0%ED%84%B0)** : 인터넷 공유기를 떠올리자, 라우터는 한개의 인터넷 회신을 여러개의 네트워트가 사용할 수 있도록 쪼개주는, 중계 역할을 해주는 장치다.
- **[라우팅(Routing)](https://expressjs.com/ko/starter/basic-routing.html)** : 엔드 포인트(URI, 경로)의 정의, 해당 엔드포인트에 대한 클라이언트 요청에 애플리케이션이 응답하는 방식이다.
라우팅은 경로를 찾아가게 하는 과정이고, 라우트는 경로이다.
라우팅에 의한 결과가 바로 라우트이다.

**req.params / req.query / req.body**
1. **req.params**
- 라우터의 매개변수
- 예를 들어 /:id/:name 경로가 있으면 ":id"속성과 ":name"속성을 req.params.id, req.params.name으로 사용할 수 있다
2. **req.query**
- 경로의 각 쿼리 문자열 매개 변수에 대한 속성이 포함 된 개체.(주로 get요청)
- 예를 들어 [localhost:3000/farm/fruit?name=apple] 이면, name=appe 부분을 객체로 매개변수의 값을 가져온다.
3. **req.body**
- JSON등의 바디 데이터를 담을 때 사용한다.
- 주로 POST로 유저의 정보 또는 파일 업로드를 보냈을 때 사용
- 요청 본문에 제출 된 키-값 데이터 쌍을 포함한다.

**미들웨어**
- 요청과 응답의 중간에 위치하여 미들웨어라고 부른다.(중간 매개역할)
![[첨부 파일 소스/Image File 1/Pasted image 20240215112115.png]]
- **'/'** 로 해당 경로에서만 미들웨어가 동작하게 지정해줄 수 있다.
- **req** : 요청, **res** : 응답, **next( )** : 다음 미들웨어로 넘어감.
- function(req, res next) 이후 **{ } 안에 부분이 바로 미들웨어.**
- **res응답이 나오면 주기가 종료되고, next가 나오면 그 다음 미들웨어한테 순서를 이어준다.**
라우트로 요청을 받아서 시작하고, res로 응답을 주기 전까지의 동작에 해당하므로 요청과 응답의 중간에 위치하여 작동하는 것이다

일반적으로 라이브러리와 프레임워크는 다른 사람이 작성한 코드이고, NPM같은 도구를 이용해 다운로드해서 사용하는 방식이다.

**라이브러리와 프레임워크의 차이**
- **라이브러리** : 사용자가 언제 기능을 사용할 지 결정해서 사용하고, 작은 HTTP요청이나 terminal텍스트 색상 변경 등 작은 일을 한다.

- **프레임워크** : 프레임워크의 작동 원리에 따라서 코드를 작성해야 함. 개발 속도와 다양한 기능을 얻는 대신 자유도,유연성이 낮은 대신 웹 앱이나 게임을 만드는 등 큰일을 하고 간결하고 개방적.



![[첨부 파일 소스/Image File 1/Pasted image 20240203131629.png]] **app.set**
- 서버 설정을 위한 속성을 지정.
- 주요 속성 이름들 ex>app.use('view engine', 'ejs')


**라우트의 순서도 중요**
- Create 로직을 짤 때 new가 :id보다 아래에 있으면 new를 id이름으로 인식해서 에러가 난다. new구문을 :id보다 위에 올려줘야 함.

**경로 매개변수**
![[첨부 파일 소스/Image File 1/Pasted image 20240202161105.png]]
- " : "이후의 문자를 입력받아 parameter에 저장한다.

**Get VS Post**
![[첨부 파일 소스/Image File 1/Pasted image 20240203083713.png]]
**app.get**
- 정보를 받아와서 화면에 띄울 때 사용
**app.post**
- 아이디, 글 내용 등의 데이터 보낼 때 사용

**CRUD**
**데이터 베이스 프로그래밍의 가장 기본 !! Create,Read,Update,Delete**
관계형 데이터 베이스든 NoSQL이던간에 모두 CRUD가 기본이다.

**RESTfull**라우트 예시![[첨부 파일 소스/Image File 1/Pasted image 20240203114559.png]]
**REST**
- 클라이언트와 서버가 어떻게 소통해 하는가에 대한 개념, 가이드라인.
- REST가 가이드라인 표준이라면 RESTfull은 이 REST규칙에 따르는 시스템.

**Update**
- Put과 Patch 둘 중 하나 사용.
- Put : 객체를 **재정의**하거나 **교체**할 때 사용.
- Patch : 문서나 객체의 **일부**를 변경할 때 사용.

**find구문 이해**
![[첨부 파일 소스/Image File 1/Pasted image 20240203155512.png]]
- comments배열을 순환하면서 c라는 매개변수의 c.id가 위에서 선언한 변수 id와 같은지 찾고 일치하면 해당 객체 반환.
#### Express 에러 처리

![[첨부 파일 소스/Image File 1/Pasted image 20240215114610.png]]
- 코드에서 try..catch로 에러를 잡고 next(err)를 통해 에러 전달하면, 바로 에러 처리 미들웨어로 점프하여 에러를 처리하게 된다. 

비동기 함수의 경우에는 모두 try..catch문으로 감싸줘야 하지만 너무 번거로우므로 헬퍼 함수를 하나 만들어서 붙여주면 훨씬 용이하다.
EX)
```
function wrapAsync(fn) {
  return function (req, res, next) {
    // 모든 오류를 .catch() 처리하고 next()로 전달하기
    fn(req, res, next).catch(next);
  };
}
```
- wrapAsync라는 헬퍼 함수를 만들었으면 비동기 함수의 async앞에 붙여서 감싸주기.

Express에서 에러 처리를 하기 위해 네 개의 매개변수가 있는 함수를 쓸 때(err, req, res, next) Express가 첫 매개변수인 err를 미들웨어 취급 해서 라우트에서 발생하거나 발생 된 오류가 있는 경우 처음으로 일치하는 항목을 호출하고 에러 처리를 위한 함수를 계속해서 호출한다. 때문에 맨 마지막에 배치를 해야 함.

특정 오류를 골라냈으면, 오류를 수정하거나 그걸 기반으로 오류를 렌더하는 등의 작업을 하면 된다.

## EJS
- 자바스크립트를 사용할 수 있는 Html 파일
- <%= asdfasdf %>를 통해 자바스크립트 문법 사용
- <% 는 조건문일 때 사용

**절대경로 설정**
- 파일 불러올 때 nodemon을 실행한 위치 기준으로 경로가 설정되므로
![[첨부 파일 소스/Image File 1/Pasted image 20240202213119.png]]
- path.join을 통해서 절대경로 설정을해줘야 한다.
- dirname은 현재 파일이 실행되는 위치를 뜻하고
- /public은 찾을 폴더를 의미. 현재주소 + public이라는 이름의 폴더를 의미.

**ejs 템플릿 만들기**
![[첨부 파일 소스/Image File 1/Pasted image 20240202232705.png]]
- ejs파일을 만들고 거기에 템플릿으로 쓸 내용을 담아서 위 코드 한줄로 여러 페이지에 적용할 수 있다.
- 수정 시에 템플릿만 수정하면 여러 페이지에 다 적용되므로 매우 편리함.
![[첨부 파일 소스/Image File 1/Pasted image 20240202232837.png]]
- 훨씬 깔끔해짐
## MongoDB

**BSON**
![[첨부 파일 소스/Image File 1/Pasted image 20240207121634.png]]
- BSON : 이진법JSON. JSON보다 더 다양한 타입의 데이터를 담을 수 있고, 압축해서 담기 때문에 저장 공간도 더 적게 차지한다.

MongoDB 데이터 저장

**One-to-N** 세 가지 방법
	각 방법은 장단점을 갖고 있으므로 N의 규모가 어느 정도인지 판단하는 것이 중요하다.
1. **One to few** : 데이터를 배열로 삽입
2. **One to Many** :부모의 레퍼런스에 배열로 자식의 ObjectID를 저장.
3. **One to Squillions** : 부모의 ID를 자식의 개별 데이터마다 저장.
- EX) 사용자의 트위터가 무수히 많을 수 있으므로, 사용자의 데이터에 모든 트윗을 저장하는 것이 아니라, 각각의 트윗마다 사용자의 ID를 저장.

![[첨부 파일 소스/Image File 1/Pasted image 20240215165453.png]]
**Populate** : ObjectID로 되어있는 데이터를 불러와서 저장.

**ref**
스키마에서 해당 컬렉션을 참조 
![[첨부 파일 소스/Image File 1/Pasted image 20240215155824.png]] 
- 위 코드에서는 user부분에 User컬렉션의 데이터를 가져와서 objectID 타입으로 저장한다는 뜻.

**장미빛 MongoDB를 위한 6가지 원칙**
1. 피할 수 없는 이유가 없다면 문서에 포함할 것.
2. 객체에 직접 접근할 필요가 있다면 문서에 포함하지 않아야 함.
3. 배열이 지나치게 커져서는 안됨. 데이터가 크다면 one-to-many로, 더 크다면 one-to-squillions로. 배열의 밀도가 높아진다면 문서에 포함하지 않아야 함.
4. 애플리케이션 레벨 join을 두려워 말 것. index를 잘 지정했다면 관계 데이터베이스의 join과 비교해도 큰 차이가 없음.
5. 비정규화는 읽기/쓰기 비율을 고려할 것. 읽기를 위해 join을 하는 비용이 각각의 분산된 데이터를 찾아 갱신하는 비용보다 비싸다면 비정규화를 고려해야 함.
6. MongoDB에서 어떻게 데이터를 모델링 할 것인가는 각각의 애플리케이션 데이터 접근 패턴에 달려있음. 어떻게 읽어서 보여주고, 어떻게 데이터를 갱신한 것인가.

**Mongo Shell 명령어**

**생성**
- use.DATABASE( name ) : 데이터 베이스 생성. 이미 있으면 해당 dbs사용
- db.createCollection( name, [options] ) : collection생성.
- db.Collection.insert( document ) : document 추가

**목록 보기 : show**
- show dbs : 데이터베이스 목록 보기
- show collections : 콜렉션 목록 보기

**삭제** 
- db.dropDatabase( ) : 선택하고있는 데이터베이스 삭제
- db.Collection.drop(  ) : 선택하고있는 콜렉션 삭제
- db.Collection.delete( 객체값 ) : 객체가 가지고 있는 값을 입력하면 해당 객체 삭제. deleteMany는 전체삭제 deleteOne은 하나만 삭제.

**업데이트**
![[첨부 파일 소스/Image File 1/Pasted image 20240207160418.png]]
- db.collection.updateOne :매치되는 첫 항목만 업데이트
- db.collection.updateMany: 모든 항목 업데이트
- $set은 업데이트 쿼리에서 가장 많이 쓰이는 연산자이다. $currentDate(최종 수정일)같은 연산자도 쓰이기도 함.

터미널에서 많은 양의 정보가 업데이트 되는 경우 mongosh에서 내용을 다 보여주지 않는다. 그럴 경우 iterate의 it을 입력해서 업데이트 가능.
#### Mongoose
**기존 Mongo를 개선하여 JavaScript측면에서 더욱 친숙하고 강력하게 만들어줌**.
편의성을 향상시켜주고 여러 기능들을 추가한 것이지, Moongoose로 할 수 있는 작업은 Mongoose없이도 가능하다.

쉽게말해 원래는 터미널에서 mongosh로 작업해야 하는 일을 javascript에서 할 수 있게 해주는 것.

**몽구스 미들웨어**
- mongoose에서의 미들웨어는 express의 미들웨어와는 완전히 다르다. mongoose의 미들웨어는 함수의 시작과 전에 pre와 post를 통해 함수를 실행하는 것이다.

**스키마**
-  스키마는 데이터베이스의 테이블, 컬렉션의 타입과 속성을 정의해 각각의 필드에 저장하는 값에 의존성을 부여합니다. **mongoDB에는 스키마가 없기 때문에 몽구스를 사용해서 스키마를 생성합니다.**

**유효성 검사**
- 스키마에서 조건을 설정해둬서 객체를 추가하는 경우에는 유효성 검사에 걸리지만, 업데이트 하는 경우에는 유효성 검사에 걸리지 않으므로 업데이트시에 runValidators: true 객체를 추가해줘야 한다.

**인스턴스 메서드**
product.find( ) : product자체에 있는 메서드
const bike = new product({name:Tire Pump, price: 100, onSale: false})
bike.save( ) 여기서 save( ) 같은 경우는 product클래스 내에 있는 인스턴스에 대한 메서드이다. bike가 product의 인스턴스.

인스턴스 메서드에서 this는 개별 인스턴스를 가리키고, 
정적 메서드에서 this는 클래스나 모델 전체를 가리킨다.

**인스턴스 메서드 만들기 예시**
const Product = mongoose.model('Product', productSchema);
%% ------- 모델 만들기 -------- %%

const productSchema = mongoose.Schema({
	name: {
		type: String
	}
})   %% ------- 스키마 추가 ---------  %%

productShcema.methods.greet = function( ) {
	console.log("hello ! ! !");
	console.log(백틱-from ${this.name}백틱)
}  %% ------ 메소드 만들기 -------  %%

const p = new Product ({name:'bike handle'})
%% ------- 인스턴스 생성 ------- %%

p.greet( )
 ㄴ> hello ! ! ! -from bike handle
 %% --------- 실행과 실행 결과 ---------- %%

### 키보드 프로젝트

#### 에러 리스트
1. 타이틀 화면 app.get을 use로 써서 요청 안됨
2. ejs패키지 설치 안해서 검색 x
3. 진짜 2시간동안 끙끙 맨 문제인데 ejs에서 변수명을 switches로 하고 for of 문을 돌리기 위해 switch라는 단어를 사용했는데 계속 switch라는 단어를 인식 못하겠다고 나오는 것이였다. 나중에 알고보니 switch라는 단어가 ejs구문에서 사용되는 문법이기 때문에 사용 불가능 했던 것. 다음부터는 SyntaxError: Unexpected token이라고 뜬 것 처럼 에러의 종류를 확실히 파악하고 접근하자.

**배운점**
- form의 action, a태그의 href, app.method의 url에서 각각의 주소가 어떤 것을 의미하고 어디로 전송되고 데이터를 받아오는지 명확히 이해하고 있어야 로직을 짤 수 있다.
- form action : action의 url로 요청을 전송
- a - href : href의 주소로 이동
- app.method - url : url로 오는 method 요청에 대해 응답하는 방법을 결정


### YelpCamp

**양식 유효성 검사**

브라우저 기반 유효성 검사는 브라우저별로 다르고 직관적이지 않으므로, 부트스트랩을 통해 진행.
![[첨부 파일 소스/Image File 1/Pasted image 20240214153316.png]]
- novalidate로 기본 유효성 검사 off 그리고 validated-form 클래스 추가
- 양식별로 input에 require에서 필수항목 만들어
- 올바르게 입력 시 텍스트 출력 기능 : input 뒤에`<div class="valid-feedback">looks good</div>`삽입
- 맨 마지막에 스크립트 삽입
- https://getbootstrap.com/docs/5.3/forms/validation/#how-it-works



### SQL
many to many로 이루어진 데이터의 경우 각자의 공간에 저장되어있는 데이터를 받아 새로운 공간에 넣는 데이터베이스.


### 보안

**Mongo의 injection**
- $등의기호를 사용해서 사용자 전체를 찾을 수 있는명령어로악용. -> express.mongo-sanitize 패키지를 통해서 특정 문자입력 제한.
**Cross Site Scripting (XSS)**
- 입력창을 통해서 남의 웹사이트에 스크립트삽입하는 공격. 
**sanitize-html**
- 입력창에 html명령어나 스크립트 입력하는 거 막아주는 패키지 
**helmet**
- 클릭공격 막아주는 패키지

## React

웹 페이지의 컴포넌트를 잘게 쪼개주는 Java Script 라이브러리

웹페이지를 브라우자가 이해하려 DOM(Document Object Model) 이 필요하다.
DOM은 JavaScript를 통해 동적으로 조작할 수 있으며, React는 DOM이 업데이트 될 때 변경된 DOM과 이전 DOM을 비교하여 변경된 부분만 업데이트 하여 효율적이다.
- DOM생성 -> 변경된 부분이 생기면 가상DOM생성 -> 이전 DOM과 가상 DOM을 비교하여 다른 부분만 실제 DOM으로 업데이트.

React의 자세한 렌더링 과정은 다음과 같다.
1. **초기 렌더링(Initial Rendering)**:
    - React 애플리케이션이 로드되면, React는 가상 DOM을 생성합니다.
    - 컴포넌트의 `render` 메서드를 호출하여 JSX를 반환합니다. 이 JSX는 Virtual DOM의 트리 구조로 변환됩니다.
2. **가상 DOM 업데이트(Virtual DOM Update)**:
    - 상태(State)가 변경되거나 프로퍼티(props)가 변경되면 React는 새로운 가상 DOM을 생성합니다.
    - 이전 가상 DOM과 새로운 가상 DOM을 비교하여 변경된 부분을 식별합니다.
3. **실제 DOM 업데이트(Real DOM Update)**:
    - 변경된 부분을 찾은 후, React는 이를 실제 DOM에 반영합니다.
    - 변경된 부분만을 업데이트하므로, 전체 DOM을 다시 렌더링하는 것보다 효율적입니다.


**JSX(JavaScript Syntax Extension)**
- 자바스크립트내부에 HTML을 작성할 수있게해주는 확장문법.   

- `<input>` 처럼 닫는 태그가 없는 경우 태그 끝을 반드시 닫아줘야 한다. -> <input />  
- { } 안의 내용은 JavaScript 구문으로 취급한다.  

**반환 시 괄호 필수**
![[첨부 파일 소스/Image File 1/Pasted image 20240226181556.png]]
- return 할 때 여러 줄 인 경우 어떤 태그로든지 감싸줘야 한다.  

**jsx내에서 스타일 만들기**
![[첨부 파일 소스/Image File 1/Pasted image 20240226193648.png]]
- style이름으로 지정하고  style태그로 적용
- 스타일 내부에 자바스크립트 구문 삽입 가능

**리액트,자바스크립트는 메소드들이 카멜케이스로 이루어져있음**
#### Components(컴포넌트)
- 리액트의 빌딩 블록. 컴포넌트는 대부분 함수.
- view의 logic과 html및 css를 결합하는 함수.
- 컴포넌트 생성할 때 PascalCase 규칙 안따르면 에러 발생.
- 컴포넌트는 그냥 한 번 실행되고 마는 함수에 불과하다.
	다른 파일에 있는 함수를 리액트가 실행시키는 것 뿐이다. 
- **컴포넌트가 다시 실행되는 경우**
	- useState 훅을 사용한 State 변경
	- 부모 컴포넌트가 다시 렌더링될 때
	- 컴포넌트의 프로퍼티(props)가 변경될 때
#### Props(프로퍼티)
- ![[첨부 파일 소스/Image File 1/Pasted image 20240319201211.png]]
- 컴포넌트로 전달 된 데이터. 변경 불가.

#### [[State]](상태)
- 컴포넌트의 모든 인스턴스에 특화된 데이터. 변경 가능.
- 주어진 컴포넌트 안에서 바꿔야 할 데이터가 있는 경우 사용
- 하나의 컴포넌트 안에서 여러 개의 State를 만들어도 서로에게 영향 X
	**UseState**
	- [[리액트 훅]]의 한가지 예로써, 컴포넌트에 State를 추가해준다.
	- *사용 방법*
		- `import { useState } from "react"` UseState 불러오기.
		- `Const [count( State를 의미함 ), setCount( State를 바꿔주는 함수 )] = useState(0)`
		- 배열 요소의 첫 번째 이름이 x라면 두번째 함수는setX 패턴으로 바뀜. 
- 
- 요소 목록(ex. array)이 있으면 key값이 필요함.
	**State에서의 배열을 업데이트 하는 방법**![[첨부 파일 소스/Image File 1/Pasted image 20240228211550.png]]
	- 상태의 불변성(immutable)을 유지하는 것은 중요하기 때문에 기존 State의 배열을 직접 수정하지 않고, 새로운 배열을 생성한 뒤 수정한다.
	- *Add*
		- `[... array, { id: asdf, product: "table"}]`
		- 기존 배열 전개해서 새로운 배열 만들고 추가
	- *Delete*
		- `array.filter((item) => item.id !== 2)` `//2번 id가진 요소 제거`
		- filter로 제거하고 싶은 배열을 제외한 구성요소로 배열 재구성.

![[첨부 파일 소스/Image File 1/Pasted image 20240311124256.png]]
- jsx에는 for구문이 있으므로 label에 for 대신 htmlFor를 사용한다.

**유효성 검사 라이브러리**
- https://www.react-hook-form.com/get-started

#### UseEffect
state로 인해 컴포넌트가 재실행 될 때 지정해둔 값이 변할때만 실행하게 만들어줌.
![[첨부 파일 소스/Image File 1/Pasted image 20240321170733.png]]
- denpendencies의 값이 변경될 때만 실행

