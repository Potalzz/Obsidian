## 알고리즘
### 조합, 순열 구하기
#### 중복 X, 순서 상관 X 조합의 구하기.
**코드(DFS 백트래킹)**
```
const result = []
const arr = [1,2,3]

function dfs(start, curr) {
	if (curr.length > 0) {
		result.push([...curr])
	}

	for (let i = start; i < arr.length; i ++) {
		// 요소 추가해준 뒤 재귀 호출
		curr.push(arr[i])
		// 다음 index부터 추가
		dfs(i + 1, curr)
		// 이전에 추가해준 요소 제거하고. 다음 요소부터 다시 재귀적으로 반복
		curr.pop()
	}
}

dfs(0, [])
console.log(result)

// 출력 예시
[ [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3] ]
```

**n = 배열의 길이**
**총 조합의 개수 :**  $2^n$ `(공집합 포함)`
**시간 복잡도 :** $O(n \cdot 2^n)$

---

#### 중복 X 순서 상관 O 조합 구하기 (순열)
**코드 (DFS)**
```
const arr = [1, 2, 3]
const result = []
function dfs(curr, remaining) {
	if (remaining.length === 0) {
		result.push(curr)
		return
	}
	for (let i = 0; i < remaining.length; i ++) {
		const newPermutation = curr.concat(remaining[i])
		const nweRemaining = remaining.slice(0, i).concat(remaining.slice(i + 1))
		permute(newPermutation, newRemaining)
	}
}

dfs([], arr)
console.log(result)

// 출력 예시
[ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ]

```

**n = 배열의 길이**
**총 순열의 개수 :**  $n!$
**시간 복잡도 :** $O(n \cdot n!)$

---

#### 중복 조합
**코드 (DFS 백트래킹)**
```
const arr = [1, 2]
const result = []
function dfs(curr, start, len) {
	// 현재 조합의 길이가 지정한 길이(=len)와 같으면 결과에 추가
	if (curr.length === len) {
		result.push([...curr])
		return
	}

	// 재귀 호출 : 배열의 요소를 추가하여 조합 생성
	for (let i = start; i < arr.length; i ++) {
		curr.push(arr[i])
		dfs(curr, i, len)
		curr.pop()
	}
}

dfs([], 0, 2)
console.log(result)

// 출력 결과
[ [1, 1], [1, 2], [2, 2] ]
```

**n = 배열의 길이, m = 길이**
**총 조합의 개수 :**  $C(n+m−1,m)$ 이항 계수 $C$의 식은 $C(n,k)= n! / k!(n−k)!​$
**시간 복잡도 :** $O(n^m)$


### 동적 계획법(Dynamic Programing)
동적 계획법에서 동적이란 단어는 **별다른 의미를 가지지 않는다**.

>**이름의 유래**
>영국인들에게 Programming이란 최적화(Optimization)을 의미한다.
>DP는 리처드 벨먼(벨만-포드 알고리즘 창시자)가 개발했으며, 벨만-포드 알고리즘의 기초라고 할 수 있다.
>리처드 벨먼이 DP를 개발할 당시 수학 연구에 대한 내용을 숨기기 위해 다소 쉬운 Dynamic Programming으로 이름을 지은 것이다.

#### 동적 계획법이란 ?
- 메모리를 절약하여 수행시간을 효율적으로 향상시키는 방법.
- 이미 계산된 결과는 별도의 메모리 영역에 저장하여 중복 계산을 막는다.
- DP(Dynamic Programing)은 일반적으로 두 가지 방식(Top-down, Bottom-up)으로 구현한다.

#### 동적 계획법 사용 조건
`다음 두 조건을 만족할 때 동적 계획법 사용 가능`
**최적 부분 구조(Optimal Substructure)**
- 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아 큰 문제 해결 가능
**중복되는 부분 문제 (Overlapping Subproblem)**
- 동일한 문제를 반복적으로 해결해야 함

#### 메모이제이션(Memoization)
- 이전에 계산된 결과를 일시적으로 기록해 놓는 기법
- `동적 계획법`을 구현하는 핵심 기법으로 활용된다
- 한 번 계산한 결과를 메모리에 저장해 두어 `중복 계산 방지`
- 메모리라는 공간 비용을 투입해, 계산에 소요되는 시간 비용을 줄여줌
- `캐싱(caching)`이라고도 한다.

#### 메모이제이션을 통한 피보나치 수열 구현방법
**메모이제이션 X**
```
const fib = (n) => {
    if(n < 2) return n
    else return fib(n-1) + fib(n-2)
}
```
값을 구할 때 마다 이전에 구했던 피보나치의 값을 다시 계산

**메모이제이션 활용**
```
let memory = [0,1,1,2,3]
    const fibonacci = (n) => {
    	if(memory[n]) {
    		return memory[n]
    	} else {
    		return memory[n] = fibonacci(n-1) + fibonacci(n-2)
    	}
    }
```
이전에 구한 피보나치의 값을 memory에 저장함으로써 한 번 계산한 값은 꺼내서 사용 가능하다.

#### Top-Down(하향식) vs Bottom-Up(상향식)
![[첨부 파일 소스/Image File 1/Pasted image 20240708161735.png]]

- `동적 계획법`의 전형적인 형태는 `바텀업` 방식
- `동적 계획법에`서 결과 저장용 리스트는 `DP 테이블` 이라고 부른다

#### 동적 계획법 구성 단계

**DP의 이론적 단계**
(순서는 상관이 없다)
>1) 하위 문제 정의
>2) 해 일부분 추측
>3) 하위 문제와 해 연결
>4) 알고리즘 구성
>5) 원래 문제와 비교

**DP 실제 구현 흐름**
1. **문제 분석** : 주어진 문제를 부분 문제로 나누고, 부분 문제의 해결 방법 고민
2. **점화식 도출** : 부분 문제 간의 관계를 정의하는 점화식 도출.
3. **메모이제이션 구현 또는 바텀업 방식 구현** : 점화식을 바탕으로 `메모이제이션(재귀 호출)`을 구현하거나, `바텀업(반복문)` 방식으로 해결.
4. **해결** : 점화식을 이용하여 문제를 해결하고, 필요에 따라 최적화 진행.

### 다익스트라(Dijkstra) 알고리즘
#### 💡 다익스트라 알고리즘이란 ?
`그리디 알고리즘`의 대표적인 최단 경로 탐색 알고리즘이다.
`다익스트라 알고리즘`은 특정한 하나의 정점에서 다른 모든 정점으로 가는 최단 경로를 알려준다. 음의 간선은 포함할 수 없으므로, 음의 간선을 활용해야 하는 경우 `벨만-포드 알고리즘`을 활용하여 해결할 수 있다.

다익스트라 알고리즘의 최단 거리를 구하는 방식은, **최단 거리는 여러 개의 최단 거리로 이루어져 있다.** 라는 점을 통해서 큰 문제를 작게 쪼개어 계산한다는 점에서 다이나믹 프로그래밍이라고도 볼 수 있지만, 완벽하게 같지는 않다.

#### 🔎 다익스트라 vs 다이나믹 프로그래밍
`다익스트라`는 하나의 최단거리를 구할 때 이전에 구했던 최단 거리 보를 그대로 사용한다. 하지만 기본적으로 다익스트라 알고리즘은 `그리디 알고리즘` 의 원칙처럼 매 순간 최적의 해를 선택한다.

**공통점**
>- 두 알고리즘 모두 문제를 해결하기 위해 작은 하위 문제로 나누어 해결하는 방식으로 작동한다.

**차이점**
>- **다이나믹 프로그래밍**은 하위 문제의 해를 저장하여 중복 계산을 줄이는 반면, **다익스트라 알고리즘**은 그리디 접근 방식을 통해 매 단계에서 최적의 선택을 하여 전체 문제를 해결한다.

>- **다이나믹 프로그래밍**은 문제의 모든 하위 문제를 고려하여 결과를 저장하고, 이를 종합하여 최적해를 구한다. 반면, **다익스트라 알고리즘**은 현재 상태에서 가장 유리한 선택을 반복하여 최단 경로를 찾는다.

#### ⚒️ 다익스트라 알고리즘 동작 과정
**노드를 방문하면서 현재까지 알고 있던 최단 경로를 계속해서 갱신한다.**

>1. 출발 노드를 설정한다
>2. 출발 노드를 기준으로 각 노드의 최소 비용을 저장한다. (연결되어있지 않은 경우 무한)
>3. 방문하지 않은 노드 중에서 1번 노드에서부터 가장 비용이 적은 노드를 선택한다.
>4. 해당 노드를 거쳐서 특정한 노드로 가는 경우를 고려하고 최소 비용을 갱신한다.
>5. 위 과정에서 3번 ~ 4번을 반복한다.

다음의 예시를 통해 좀 더 자세하게 살펴보자.
![[첨부 파일 소스/Image File 1/Pasted image 20240802174208.png]]
해당 그래프에서 1번 노드부터 시작하여 모든 노드까의 최단거리를 알고 싶은 경우, 과정은 다음과 같다.

먼저 1번노드에서 다른 노드들을 거치지 않고 방문할 수 있는 노드 (= 즉 인접 노드)들의 비용을 저장한다.

| 1        | 2   | 3   | 4   | 5   | 6   | 7   |
| -------- | --- | --- | --- | --- | --- | --- |
| `0 (방문)` | 5   | 15  | 무한  | 4   | 1   | 무한  |
`1번` 노드는 방문 했으므로 방문처리 해주고, 방문하지 않은 노드 중에서 비용이 가장 낮은 노드인 `6번` 노드를 방문한뒤, 방문처리 해준다.

`6번` 노드에서 방문할 수 있는 노드들을 방문하고, **시작 노드(`1번`)에서 `6번` 노드를 거쳐 다른 노드를 방문하는 경우** `Ex(1 -> 2로 바로 방문하는 것 보다 1 -> 6 -> 2로 방문하는 경우)`가 원래 비용이 낮은 경우 비용을 업데이트 해준다. 

![[첨부 파일 소스/Image File 1/Pasted image 20240802174726.png]]

| 1        | 2     | 3   | 4   | 5     | 6        | 7     |
| -------- | ----- | --- | --- | ----- | -------- | ----- |
| `0 (방문)` | **4** | 15  | 무한  | **2** | `1 (방문)` | **8** |
이렇게 업데이트 된 비용을 가지고, 다시 낮은 경우를 선택해 업데이트를 진행해준다.
예시에서는 다음 경우까지만 살펴보겠다.

**다음으로 비용이 낮은 노드**는 `2의 비용`을 가지고 있는 `5번`노드.

![[첨부 파일 소스/Image File 1/Pasted image 20240802175406.png]]

방문한 노드인 `2번`노드에서 시작노드를 제외 한 인접노드인 `4번`, `6번` 노드까지의 비용을 계산해보자.

**2번 노드를 거쳐 `6번`노드 까지의 비용**
 `1번 --(5)--> 2번 --(3)--> 6번` 총 `8`의 비용으로 기존 비용인 `1`보다 더 높으므로 업데이트 하지 않는다.

**2번노드를 거쳐 `4번`노드 까지의 비용**
 `1번 --(5)--> 2번 --(2)--> 4번` 총 `7`의 비용으로 기존 비용인 `무한`보다 더 낮으므로 업데이트 해준다.

| 1        | 2        | 3   | 4     | 5   | 6        | 7   |
| -------- | -------- | --- | ----- | --- | -------- | --- |
| `0 (방문)` | `4 (방문)` | 15  | **7** | 2   | `1 (방문)` | 8   |

이 과정을 모든 노드를 방문할 때 까지 반복해주면, 시작 노드에서부터 모든 노드까지의 최단 거리(비용)를 구할 수 있다.


## 수학
### 그래프(Graph)
그래프(Graph)는 객체 사이의 연결 관계를 표현할 수 있는 자료 구조로 실제 세계의 현상이나 사물을 `정점(vertex)`과 `간선(edge)`으로 표현한 것이다.
**정점(vertex)** 은 여러가지 특성을 가질 수 있는 객체를 의미하며, `노드(node)`라고도 불림.
**간선(edge)** 은 정점과의 관계를 의미하며, `(link 또는 branch)`라고도 불림.

#### 그래프의 용어
| 용어         | 설명                          |
| ---------- | --------------------------- |
| **정점의 차수** | 무방향 그래프에서 하나의 정점에 인접한 정점의 수 |
| **진입 차수**  | 방향 그래프에서 외부에서 오는 간선의 수      |
| **진출 차수**  | 방향 그래프에서 외부로 향하는 간선의 수      |
| **경로길이**   | 경로를 구성하기 위해 사용된 간선의 수       |

#### 그래프의 종류

*무방향 그래프와 방향 그래프*
링크의 종류에 따라 **무방향 그래프(undirected graph)** 와 **방향 그래프(directed graph)** 로 나눌 수 있다. **무방향 그래프**는 간선에 방향이 존재하지 않아, 양방향의 노드(=정점)로 이동할 수 있다. **방향 그래프**는 간선에 방향이 존재하므로 정해진 한 방향으로만 이동할 수 있다.

*가중 그래프 또는 가중 네트워크*
링크에 가중치를 할당하여 노드 간의 연결 유무뿐 아니라 연결 강도까지 나타낼 수 있다. 가중 그래프는 무방향 그래프이며, 가중치를 통해 보다 복잡한 관계를 표현할 수 있다.

*연결 그래프와 비연결 그래프*
무방향 그래프에서 모든 노드에 항상 링크가 존재한다면, **연결 그래프(connected graph)** 이고, 특정 노드에 대한 링크가 없는 그래프는 **비연결 그래프(disconnected graph)** 라고 한다.

*완전 그래프*
그래프에 있는 모든 노드가 서로 연결된 경우 **완전 그래프(complete graph)** 라고 한다. 링크의 개수는 노드의 개수 n에 대하여 `n * (n - 1) / 2`이다.

*부분 그래프*
어떤 그래프의 노드 일부와 링크 일부로 이루어진 그래프를 **부분 그래프(sub graph)** 라고 한다. 부분 그래프는 참조한 그래프에의 원소이다.

#### 그래프와 트리의 차이
|          | 그래프                          | 트리                         |
| -------- | ---------------------------- | -------------------------- |
| 정의       | 노드와 노드를 연결하는 간선으로 표현되는 자료 구조 | 그래프의 한 종류, 방향성이 있는 비순환 그래프 |
| 방향성      | 방향 그래프, 무방향 그래프 둘다 존재함       | 방향 그래프만 존재함                |
| 사이클      | 사이클 가능함, 순환 및 비순환 그래프 모두 존재함 | 비순환 그래프로 사이클이 존재하지 않음      |
| 루트 노드    | 루트 노드 존재하지 않음                | 루트 노드 존재함                  |
| 부모/자식 관계 | 부모 자식 개념이 존재하지 않음            | 부모 자식 관계가 존재함              |

#### 그래프의 표현 방법
프로그래밍에서 그래프는 크게 2가지 방식으로 표현한다.
`인접 행렬(adjacency matrix)`과 `인접 리스트(adjacency list)`이다.

**인접 행렬**은 2차원 배열로 각 노드의 연결 관계를 표현하는 방식이다.
`가중치가 없는 경우` 해당 노드와 연결된 경우 1 연결이 안된 경우 0으로 표기한다.
`가중치가 있는 경우` 해당 노드와 연결 된 경우 가중치를 표기하고, 연결이 되지 않은 노드는 무한(infinity)으로 표기한다.(무한으로 표기하는 이유는 숫자0이 가중치로 사용될 수 있기 때문)
인접 행렬 방식의 경우 2차원 배열이 중앙 대각선을 기준으로 대칭을 이룬다.

```
// 가중치가 없는 인접 행렬 그래프
const graph = [
	[0, 1, 1, 0, 0, 0], // 노드 1과 연결된 노드들 
	[1, 0, 0, 1, 1, 0], // 노드 2와 연결된 노드들 
	[1, 0, 0, 1, 0, 0], // 노드 3과 연결된 노드들 
	[0, 1, 1, 0, 1, 0], // 노드 4와 연결된 노드들 
	[0, 1, 0, 1, 0, 1], // 노드 5와 연결된 노드들 
	[0, 0, 0, 0, 1, 0], // 노드 6과 연결된 노드들
];

// 가중치가 있는 인접 행렬 그래프
const graph = [
	[0  , 4  , 2  , INF, INF, INF], // 노드 1에 대한 가중치
	[4  , 0  , INF, 5  , 3  , INF], // 노드 2에 대한 가중치
	[2  , INF, 0  , 7  , INF, INF], // 노드 3에 대한 가중치
	[INF, 5  , 7  , 0  , 1  , INF], // 노드 4에 대한 가중치
	[INF, 3  , INF, 1  , 0  , 8  ], // 노드 5에 대한 가중치
	[INF, INF, INF, INF, 8  , 0  ], // 노드 6에 대한 가중치
];
```

**인접 리스트**는 리스트로 그래프의 연결 관계를 표현하는 방식으로 모든 노드에 연결 정보를 차례대로 연결하여 저장한다. 노드에 대한 가중치가 있을 때는 가중치를 입력해주고, 가중치가 없는 경우 2차원 배열로 표기한다.

```
// 가중치가 없는 인접 리스트 그래프
const graph = [
	[1, 2, 5], // 노드 0과 연결된 노드들 
	[0, 3], // 노드 1과 연결된 노드들 
	[0, 4], // 노드 2와 연결된 노드들 
	[1, 5], // 노드 3과 연결된 노드들 
	[2, 5], // 노드 4와 연결된 노드들 
	[0, 3, 4], // 노드 5와 연결된 노드들 
];

// 가중치가 있는 인접 리스트 그래프
const weighted_graph = [
  [
    [1, 8],  // 노드 0과 연결된 노드 1, 가중치 8
    [2, 3],  // 노드 0과 연결된 노드 2, 가중치 3
    [5, 5],  // 노드 0과 연결된 노드 5, 가중치 5
  ],
  [
    [0, 8],  // 노드 1과 연결된 노드 0, 가중치 8
    [3, 12], // 노드 1과 연결된 노드 3, 가중치 12
  ],
  [
    [0, 3],  // 노드 2와 연결된 노드 0, 가중치 3
    [4, 14], // 노드 2와 연결된 노드 4, 가중치 14
  ],
  [
    [1, 12], // 노드 3과 연결된 노드 1, 가중치 12
    [5, 7],  // 노드 3과 연결된 노드 5, 가중치 7
  ],
  [
    [2, 14], // 노드 4과 연결된 노드 2, 가중치 14
    [5, 6],  // 노드 4과 연결된 노드 5, 가중치 6
  ],
  [
    [0, 5],  // 노드 5과 연결된 노드 0, 가중치 5
    [3, 7],  // 노드 5과 연결된 노드 3, 가중치 7
    [4, 6],  // 노드 5과 연결된 노드 4, 가중치 6
  ],
];
```

#### 인접 행렬 그래프와 인접 리스트 그래프 비교

| 특성        | 인접 행렬                 | 인접 리스트                       |
| --------- | --------------------- | ---------------------------- |
| 구조        | 2차원 배열                | 배열 또는 객체의 배열                 |
| 공간 복잡도    | O(V2)                 | O(V+E)                       |
| 엣지 존재 확인  | O(1)                  | 최악의 경우 O(V)                  |
| 노드의 이웃 탐색 | O(V)                  | O(V)에서 O(E)                  |
| 장점        | 빠른 링크 존재 확인           | 메모리 효율적, 희소 그래프에 적합          |
| 단점        | 메모리 비효율적, 희소 그래프에 부적합 | 링크 존재 확인이 느림, 구현이 더 복잡할 수 있음 |

#### 그래프의 탐색
그래프 탐색은 하나의 노드에서 시작해 차례대로 모든 노드를 방문하는 과정이다.
`너비 우선 탐색(BFS, Breadth-First Search)`과 `깊이 우선 탐색(DFS, Depth-First Search)` 의 두 가지 알고리즘이 사용된다.

| 특징        | BFS                     | DFS                          |
| --------- | ----------------------- | ---------------------------- |
| 탐색 구조     | 너비 우선 (수평 탐색)           | 깊이 우선 (수직 탐색)                |
| 데이터 구조    | 큐 사용                    | 스택 또는 재귀 사용                  |
| 사용 사례     | 최단 경로 탐색 (무가중치 그래프)     | 모든 경로 탐색, 미로 탐색              |
| 구현 복잡성    | 구현이 비교적 간단              | 재귀 구현이 간단하지만, 스택을 사용한 구현도 가능 |
| 순환 그래프 탐색 | 중복 방문을 방지하기 위해 방문 표시 필요 | 중복 방문을 방지하기 위해 방문 표시 필요      |

---

### 2진법
0과 1을 사용해 수를 나타내는 진법.
일반적으로 우리가 사용하는 숫자는 열 손가락으로 숫자를 세어 10진법을 사용.

### 2진수 -> 10진수 변환
2진수는 0과 1로 이루어지며 각 자리수에 해당하는 숫자는 `2^n`이 있음을 의미한다. 예를 들어 011010이라는 숫자로 예를 들어 보자. 우측 맨 끝부터 2의 0제곱, 2의 1제곱, 2의 2제곱 이렇게 올라가며 1이있으면 해당 수를 더해주고, 0일 경우 지나치면 된다. 
Ex)

| 2^5 | **2^4** | **2^3** | 2^2 | **2^1** | 2^0 |
| --- | ------- | ------- | --- | ------- | --- |
| 32  | **16**  | **8**   | 4   | **2**   | 1   |
| 0   | **1**   | **1**   | 0   | **1**   | 0   |

2진수 011010에서 1인 부분만 모두 더해주면,
16 + 8 + 2 = 36
`2진수` **011010** = `10진수` **36** 이라는 결과값이 나오게 된다.

### 10진수 -> 2진수 변환
10진수에 해당하는 수를 나눌 수 없 때 까지 나누어 준다.
그 이후 마지막 몫의 값부터 나머지 부분을 역순으로 써주면 2진수 값이 나오게 된다.

| 단계  | 나눌 값 | 몫     | 나머지   |
| --- | ---- | ----- | ----- |
| 1   | 36   | 18    | **0** |
| 2   | 18   | 9     | **0** |
| 3   | 9    | 4     | **1** |
| 4   | 4    | 2     | **0** |
| 5   | 2    | 1     | **0** |
| 6   | 1    | **0** | **1** |
`10진수` **36** = `2진수` **011010** 이라는 결과값이 나오게 된다.

## CS지식
### 객체지향 프로그래밍
단순히 행동을 컴포넌트로 분리하는 것은 절차 지향에 해당한다.
객체 지향이란 행동과 특성을 클래스를 통해 분리하고,
인스턴스나 객체에 할당하는 것을 의미한다.

**그래서 객체 지향이 뭐야 ?**
객체 지향은 각자의 객체가 자신이 맡은 역할만 충실히 이행하는 것.
자신이 맡은 분야가 아닌 경우에는, 다른 객체에게 요청하여 건네 받는다.
자신이 가진 상태는 본인이 스스로 이행해야 하며, 다른 객체에게 넘겨줘선 안된다.

`직업(class)`
`특성(attribute, property)`
`스킬(method)`
`일꾼(instance, object)`

예시로 성을 짓는다고 생각해보자.
단순히 성을 짓는데 필요한 행동들을 분리하는 것이 아니라, 성을 짓기 위해 필요한 직업군(class)을 분리한다.
각 직업군은 특성(속성(attribute), property 또는 filed라고 불림)을 부여받는다. 이 특성은 각 직업군이 갖고있는 상태를 의미한다.
직업군은 또한 각각의 스킬(메소드)을 갖고 있다.
각 직업군은 스킬(행동)을 사용할 책임을 갖게 된다.
고유 특성들은 단지 스킬을 사용하기 위한 조건에 불과하다.

위의 예시처럼 `객체지향 프로그래밍`은 가장 먼저 `역할(직업)`과 `책임(스킬과 특성)`을 설계하고 정의한다.

그리고 `인스턴스` 또는 `객체`라고 불리는 일꾼들에게 각자 직업을 배정하고 일을 시킨다.

이처럼 객체지향 프로그램밍의 코드는 각 클래스별로 모듈, 즉 클래스란 단위로 나뉘어져 있다.

`클래스`들은 보통 혼자 일하지 않고, 다른 `클래스`와 협력하여 일하며 다른 `클래스`의 `책임`을 어떻게 수행하는지에는 관여하지 않는다.
예를 들어 목수는 대장장이에게 도구 제작 스킬을 의뢰하고, 도구 제작스킬에 필요한 특성이 무엇인지에 대해서는 접근하지 않으며, private란 상태로 숨겨져 있다.(다른 `클래스(직업)`의 `객체(일꾼)`이 읽거나 수정하지 못하도록)

각 `클래스가` 자기가 맡은 `책임`에만 관심을 갖도록 하여 코드의 복잡성과 유연성을 확보한다.

**==상속(Inheritance)==**
특정 속성이나 메소드를 추가한 클래스를 만들거나, 특정 메소드의 실행방식을 수정한 클래스를 만들 때 사용.
클래스는 다른 클래스에게 `속성(특성)`과 `메소드(스킬)`를 물려줄 수 있다.
상속 받은 클래스에서는 같은 `메소드(스킬)`이라도 다르게 실행될 수 있다.
기존 클래스에서 추가적인 스킬을 갖는 `2차 전직`이라고 생각하면 됨.

==**추상 클래스**==
해당 클래스 자체만으로는 `인스턴스`에 부여하지 않는다. 더욱 구체적이어야 한다.
해당 추상 클래스의 `메소드`가 무엇을 할 지는 `extends`를 통한 `자식 클래스(2차 전직)`에서 결정된다. 즉, `인스턴스`의 역할에 따라 행동이 달라진다.

==**인터페이스**==
>인터페이스의 역할은 클래스나 객체가 특정 메서드나 프로퍼티를 반드시 구현하도록 강제하는 것이다.

서로 다른 `클래스`를 한 카테고리로 묶고 같은 이름의 책임을 부여.
자격증이라고 생각하면 된다.

>`클래스`가 직업이라면 `인터페이스`는 자격, 카테고리 같은 느낌.
>홀딩기가 있는 직업들은 역할군과 별개로 '홀더'라는 카테고리로 분류될 수 있다.
>보스몹을 홀딩하는 '홀더'라는 `인터페이스가` 있다고 해보자.
>얼음법사, 로그, 그래플러 모두 홀딩을 할 수 있어 홀더로 기용된다.
>홀딩을 할 수 있다는 자격을 부여하는 것이 `인터페이스`
>아까 각 직업은 스킬(메소드)와 특성(property)라는 책임을 가진다고 했다.
>'홀더'라는 카데고리에서 가져야 할 책임은 뭘까 ? -> '홀딩'이다.
>'홀더'라는 카테고리를 부여받은 직업들은 '홀더'의 holding() 스킬(메서드) 또한 함께 부여 받는다.
>어떤 일꾼(객체)가 부여받았는지에 따라, 어떻게 '홀딩'할 지도 달라진다.

인터페이스 자체로는 객체를 만들지 못한다. '홀더'라는 직업은 없듯이.
JavaScipt에서는 필요한 메서드나 속성을 가진 클래스를 만들고,
이를 다른 클래스에 상속함으로써, 인터페이스의 역할을 구현한다.


#### SOLID 원칙 - 객체지향 디자인 패턴의 기본기
![[Pasted image 20241024165152.png]]

==**SRP (Single Responsibility Principle)**==
**"단일 책임 원칙"** 으로 각 클래스는 하나의 책임만 갖고 있어야 한다는 의미다.

==**OCP (Open/Closed Principle)**==
**"개방/폐쇄 원칙"** 으로 각 클래스가 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다. 클래스를 수정하지말고 확장에서 사용하여야 한다.

**예시**
![[Pasted image 20241024171723.png]]
문서를 생성하는 클래스의 경우, 문서의 확장자를 검증하고 생성하게 되면 다른 확장자 검증을 추가해야 할 경우 추가하는 과정에서 기존 코드가 변경되거나 부작용이 발생할 수 있다.

![[Pasted image 20241024171740.png]]
**좋은 예시**
때문에 문서를 생성하는 기능은 클래스를 따로 만들어두고, 확장을 통해 확장자별 문서 생성 클래스를 만들어준다.

==**LSP (Linskov Substitution Principle)**==
**"리스코프 치환 원칙"** 으로 자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다.
부모 클래스가 들어갈 자리에 자식 클래스가 들어가도, 부모 클래스가 기존에 하던 일에는 지장이 없어야 한다.

![[Pasted image 20241024171503.png]]
**잘못된 예**
펭귄은 새에 속하지만 날 수는 없다. 때문에 부모인 Bird 클래스의 fly메소드를 물려받게 되면 수행할 수 없다. **LSP**원칙에 따라 해당 기능을 분리해야 한다.

![[Pasted image 20241024171516.png]]
**올바른 예**
위와 같이 해당 메소드가 모든 자식 클래스에 부합하지 않는 경우에는, Bird를 상속받아 FlyingBird를 만들어주고, 날  수 있는 새의 경우 FlyingBird에서 확장하고, 날 수 없는 새의 경우 Bird에서 확장하면 된다.

==**ISP (Interface Segregation Principle)**==
**"인터페이스 분리 원칙"** 으로 클래스는 자신이 사용하지 않을 메소드를 구현하도록 강요받지 말아야 한다.

인터페이스를 상속 받는 클래스에서 인터페이스 내부의 기능이 필요 없는 경우, 인터페이스를 분리하여 상속해야 한다.

![[Pasted image 20241024173014.png]]
**나쁜 예**
Wokrer 인터페이스에 work와 eat이 있어, 사람은 두 메서드 모두 필요하지만, 로봇은 eat메서드가 필요가 없다.

![[Pasted image 20241024173054.png]]
**좋은 예**
인터페이스를 Workable, Eatable 두 개로 분리해서, 사람은 두 인터페이스를 상속받고 로봇은 하나만 상속받는다.

==**DIP (Dependency Inversion Principle)**==
**"의존성 역전 법칙"** 으로 고수준 모듈이 저수준 모둘에 의존해서는 안된다.

![[Pasted image 20241024173431.png]]

**나쁜 예**
직접적인 동작을 하는 모듈은 **저수준 모듈**, 이를 제어하는 추상화된 로직을 제공하는 모듈은 **고수준 모듈**이다. 하지만 위의 예시에서는 저수준 모듈인 Fan클래스의 spin과 stop 메서드를 고수준 모듈인 Switch클래스 내부에서 사용되고 있기 때문에 의존적이다.

![[Pasted image 20241024174740.png]]
![[Pasted image 20241024174728.png]]
![[Pasted image 20241024175553.png]]
**좋은 예**
Switchable이라는 인터페이스를 클래스로 만들고, 저수준 모듈인 Fan에서 상속받는다. 그리고 고수준 모듈인 Switch 모듈은 Fan에 의존하지 않고, 추상화 클래스인 Switchable에 의존한다.


#### 

**Static**
햄버거 브랜드의 프랜차이즈 객체를 만들 때, 브랜드명과 CEO이름은 고정적이므로 하나만 있으면 되기 때문에 static으로 만들어준다.


### 함수형 프로그래밍
![[Pasted image 20241024110844.png]]

>절차 지향 프로그래밍 **->** 함수형 프로그래밍의 차이는
>코드가 더욱 깔끔해진다는 점도 있지만
>중요한 부분은 **변수의 사용이 최소**화 된다는 것이다.


변수가 많을 수록, 오류 발생 확률이 높아지고 테스트가 복잡해지기 때문에
함수형 프로그래밍은 변수를 개발자가 직접 다루게 되는 상황을 최소화시킨다.

함수형 프로그래밍에는 **순수 함수**만 사용된다
	**순수 함수** : 함수가 실행될 때마다 인자에 따라 동일한 결과값을 반환하는 함수. 외부에 영향을 받지 않으며, 배열이 필요할 경우 복사해와서 사용한다.

함수형 프로그래밍이 가장 많이 사용되는 경우는 **고차 함수**의 경우이다.
	**고차 함수** : 함수를 인자로 받는 함수를 의미.
	**콜백 함수** : 함수에 인자로 들어가는 함수를 의미. 자바스크립트는 함수가 1급 객체로써, 변수처럼 동일하게 처리되기 때문에 인자로 넣을 수 있다. 


![[Pasted image 20241024112357.png]]
실무에서 **함수형으로 처리한다**는 말은, 위처럼 filter, map, reduce와 같은 고차 함수 메소드를 사용해서 다루는 것을 의미한다.

**모나드**
>모나드는 함수형 프로그래밍 개념 중 하나로써, 값에 함수를 적용하여 새로운 값이 담긴 상자를 만들어내는 기능을 가진 상자.

>모나드의 기본 기능으로는 유닛(Unit), 맵(Map), 플랫맵(FlatMap)이 있습니다. 유닛은 주어진 값을 모나드로 감싸는 기능, 맵은 주어진 함수를 실행한 결과를 다시 상자에 담아 내보내는 기능, 플랫맵은 이미 상자에 담긴 값을 반환하는 함수를 처리합니다. 이런 기능들 덕분에 모나드는 프로그래밍에서 편리하게 값을 처리하고, 어려운 문제를 간소화 하는 데 도움이 됩니다.

![[Pasted image 20241024122953.png]]
flatMap처럼, 데이터에 계산을 해서 이중 포장을하지 않고 값으로 반환하는 메소드를 갖고있는 자료형은 모나드의 기능을 갖췄다고 할 수 있다.(JS의 배열) 


### Jest
Jest는 자바스크립트 테스트 프레임워크로써 빠르게 테스팅 환경을 만들 수 있다는 것이 큰 장점이다.

https://velog.io/@skyu_dev/Jest-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-JS%EC%9D%98-%EA%B8%B0%EB%8A%A5-%EC%A0%90%EA%B2%80%ED%95%98%EA%B8%B0
- 정리글

**사용 방법**
테스트 하고 싶은 파일을 <파일명>.test.js로 만들어주면 test파일로 인식한다.
`npm test를 하면 모든 테스트 케이스를 인식`

>**해당 test파일에서 테스트할 파일을 불러와주고 케이스를 작성한다**.![[Pasted image 20241025155332.png]]


### MVC 패턴(Mode-View-Controller)
MVC 패턴은 유지 보수를 목적으로 만들어진 디자인 패턴이다.

**Model** : 데이터와 관련된 부분
**View** : 사용자한테 보여지는 부분
**Controller** : Model과 View를 이어주는 부분

>**MVC 모형** ![[Pasted image 20241025194059.png]]

==**MVC 패턴 규칙**==
**1. Model은 Controller와 View에 의존하지 않아야 한다**
- Model 클래스에서 Controller와 View의 클래스를 Import해서 사용하면 안된다.

**2. View는 Model에만 의존해야 하고, Controller에 의존하면 안된다**
- View 클래스에서 Model의 클래스는 Import해도 되지만 Controller의 클래스를 Import해서는 안된다.

**3. View가 Model로부터 데이터를 받을 때는, 사용자마다 다르게 보여주어야 하는 데이터에 대해서만 받아야 한다.**

>- **예시** ![[Pasted image 20241025195059.png]]
>View는 고정적으로 보여지는 UI와 사용자별로 달라지는 데이터로 구성된다.
>사용자별 데이터는 Model로 부터 받아오고, 고정적으로 보여지는 부분은 View가 자체적으로 가지고 있어야 한다.

**4. Controller는 Model과 View에 의존해도 된다.**
- Model과 View의 중재자 역할을 하면서 전체 로직을 구성하기 때문.

**5. View가 Model로부터 데이터를 받을 때, 반드시 Controller에서 받아야 한다.**



### TDD 방법론
TDD란 Test Driven Development의 약자로 **테스트 주도 개발**이라고 한다.

반복 소프트웨어를 이용한 소프트웨어 방법론으로,
작은 단위의 테스트 케이스 작성하고 이를 통과하는 코드를 추가하는 단계를 반복하여 구현한다.
**짧은 개발 주기의 반복**

==**TDD 개발주기**==
![[Pasted image 20241030130246.png]]

- **RED** : 실패하는 테스트 추가
- **GREEN** : 테스트 코드를 성공시키기 위한 실제 코드 작성
- **BLUE** : 중복 코드 제거, 일반화 등의 리팩토링

현재 코드에서 **실패하는 테스트 코드**를 먼저 작성하고, 실패하는 테스트 코드를 통과할 정도의 **최소 실제 코드를 작성**한다.
![[Pasted image 20241030130622.png]]


**[ 좋은 테스트의 특징 ]**

그렇다고 테스트를 무작정 작성하는게 좋은 것은 아니다. 좋은 테스트를 작성해야 그 이점을 누릴 수 있는데, 좋은 테스트의 특징은 FIRST라는 5가지 규칙을 따라야 한다. 아래의 내용들은 CleanCode에 자세히 나와있다.

1. Fast: 테스트는 빠르게 동작하여 자주 돌릴 수 있어야 한다.
2. Independent: 각각의 테스트는 독립적이며 서로 의존해서는 안된다.
3. Repeatable: 어느 환경에서도 반복 가능해야 한다.
4. Self-Validating: 테스트는 성공 또는 실패로 bool 값으로 결과를 내어 자체적으로 검증되어야 한다.
5. Timely: 테스트는 적시에 즉, 테스트하려는 실제 코드를 구현하기 직전에 구현해야 한다.

**[ TDD(Test-Driven Development, 테스트 주도 개발) 방법 및 순서 ]**

TDD 개발 방법론의 프로그래밍 순서는 매우 단순하다.

1. 실패하는 작은 단위 테스트를 작성한다. 처음에는 컴파일조차 되지 않을 수 있다.
2. 빨리 테스트를 통과하기 위해 프로덕션 코드를 작성한다. 이를 위해 정답이 아닌 가짜 구현 등을 작성할 수도 있다.
3. 그 다음의 테스트 코드를 작성한다. 실패 테스트가 없을 경우에만 성공 테스트를 작성한다.
4. 새로운 테스트를 통과하기 위해 프로덕션 코드를 추가 또는 수정한다.
5. 1~4단계를 반복하여 실패/성공의 모든 테스트 케이스를 작성한다.
6. 개발된 코드들에 대해 모든 중복을 제거하며 리팩토링한다.

출처: [https://mangkyu.tistory.com/182](https://mangkyu.tistory.com/182) [MangKyu's Diary:티스토리]


### 도메인 주도 설계(Domain-Driven Design, DDD)

애플리케이션 개발에서 사용하는 도메인이라는 단어는 비즈니스적인 어떤 업무 영역과 관련이 있다.
애플리케이션을 구현하기 위해 필요한 업무들을 자세히 구분하면 도메인으로 분류를 쉽게 할 수 있다.

음식 주문 배달 어플리케이션을 만든다고 가정해보자.
- 음식을 주문하는 고객
- 주문받은 음식을 판매하는 음식점
- 완성된 음식을 배달하는 배달원
- 해당 음식을 주문하고 결제하는데 이용되는 카드사

이렇게 주문에 필요한 대략적인 것들을 각각의 도메인이라 부를 수 있다.
즉, 도메인은 현실에서 접하는 업무의 한 영역들을 말한다.

![[Pasted image 20241108153659.png]]
![[Pasted image 20241108153752.png]]

위와 같이 상위 도메인과 하위 도메인으로 나눌 수 있다.

**상위 도메인**
회원, 주문, 음식, 결제

**하위 도메인**
회원: 회원 정보, 회원 포인트
주문: 배달 주문자, 배달 정보, 주문 정보, 배달 추적 정보, 배달 주소 정보
음식: 음식 정보
결제: 결제 정보

**애그리거트(Aggregate)**
애그리거트란 비슷한 업무 도메인들의 묶음이다.
위 예시에서 애그리거트의 개수는 4개가 되며,
이를 각각 회원 애그리거트, 주문 애그리거트, 음식 애그리거트, 결제 애그리거트 등으로 부를 수 있다.

애그리거트는 도메인보다 복잡하고 어려운 개념이지만, 비슷한 범주의 연관된 업무들을 하나로 그룹화한 것으로 생각할 수 있다.

**애그리거트 루트(Aggregate Root)**
위에서 정의한 애그리거트에는 1개 이상의 도메인들이 있다.
해당 애그리거트를 대표하는 도메인을 **애그리거트 루트**라고 부른다.

