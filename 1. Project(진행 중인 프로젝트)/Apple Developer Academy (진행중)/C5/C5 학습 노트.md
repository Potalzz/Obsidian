## 벡터(Vector)가 무엇일까 ?
> 크기 + 방향을 가진 양

벡터라는 이름으로 물체의 위치를 지정하는 경우가 종종 있다, 그렇기 떄문에 벡터의 의미를 위치와 혼동하는 경우가 많은데, 벡터는 위치가 아닌 방향을 의미한다.
> **벡터에는 위치가 없다**

현실 세계에서 위치가 없는 물체는 상상하기 어렵기 때문에, 벡터를 **화살표**를 통해서 원점에서 어떠한 방향으로 가해지는 힘을 **시각화**하는 것이다.

**벡터는 선형성을 가지기 때문에 가산성에 의해 서로 결합할 수 있다.**
결합된 두 벡터는 새로운 벡터를 만들어낸다.

또한 벡터에 수를 곱해서 확장, 축소하거나 방향을 변경할 수 있는데 벡터에 곱하는 수를 **스칼라(Scalar)** 라고 한다.

### 스칼라(Scalar)란 ?
> 방향 없이 크기만 있는 양

**수학적으로 하나의 숫자를 의미**

벡터에 스칼라를 곱한다는 것의 의미는 "화살표를 길게 혹은 짧게 만드는 것"
`(3, 4, 0)`의 길이 5인 화살표(벡터)가 있다고 가정해보자.
해당 화살표에 2를 곱해주면 `(6, 8, 0)`이 될 것이고 방향은 같지만 길이가 2배인 화살표가 될 것이다.

또한, 스칼라는 스칼라 곱과는 다른 의미를 가진다.
**스칼라 곱**이란 두 벡터를 **내적**했더니 나온 결과가 숫자(스칼라)라는 뜻이다.

### 벡터의 차원
벡터는 **차원**이라는 개념으로 나타낸다.
성분이 2개인 벡터의 경우 2차원 벡터, 3개인 경우 3차원 벡터 등 다양한 차원의 벡터가 존재한다.

**예시**
동쪽 방향으로 5미터, 북쪽 방향으로 3미터 이동해서 1미터를 점프했을 때의 **이동한 거리와 방향**을 벡터로 표현하면 다음과 같다.
`V3D = [5 3 1]`

### 벡터의 기본 연산
**덧셈:** 같은 방향끼리 더해진다
	$$(1, 0, 0) + (0, 2, 0) = (1, 2, 0)$$
	
**스칼라와의 곱셉(배):** 길이만 바뀐다.
	$$2 * (1, 2, 0) = (2, 4, 0)$$
	
**길이(노름):** 벡터의 길이를 구한다.
	 $$|v| = √(x²+y²+z²)$$
	
**정규화:** 길이를 1로 만드는 것
	(긴 화살표를 같은 방향의 단위 화살표로 줄이기)
	$$v̂ = v / |v|$$

#### simd 라이브러리를 통한 연산
![[Pasted image 20250814014223.png]]


### 벡터 내적(Dot Product)
> 두 벡터의 각 성분을 곱한 후 그 결과를 모두 더하는 연산

두 벡터를 내적한 결과는 **스칼라**값이 된다.
내적은 다른 말로 **스칼라곱(scalar product)** 또는 점곱(dot product)라고 한다.

내적을 구하는 공식의 정의는 다음과 같다.
$$a \cdot b = |a||b|cos \theta$$


두 벡터 $v$와 $u$가 있을 때 내적을 좌표로 구한다면 다음과 같다.
$$\upsilon = (a, b), u = (c, d), \space \upsilon \cdot u = ac \space + bd $$

이와 같은 공식으로 인해 같은 벡터의 내적은 벡터의 크기를 제곱한 값이 된다.

벡터 내적은 두 벡터 사이의 상관관계를 나타내는 연산이며, 유용하게 활용할 수 있는 사례들이 있다.

#### 1. 유사도 측정
>내적은 두 벡터가 얼마나 유사한 방향을 가지고 있는지의 척도로 사용된다.

두 벡터가 비슷한 방향을 가지고 있을수록 내적 값은 크고, 서로 다른 방향을 가지고 있을수록 내적 값은 작아진다.
비슷한 방향일 수록 벡터의 부호가 같을 것이고, 곱한 값은 커질 수 밖에 없다.
반면에 직각을 이루는 경우, 내적 값은 0이 될 것이고 직각을 넘어 부호가 달라질 경우 곱한 값은 작아질 것이다.

#### 2. 투영(projection)
>내적을 사용해 하나의 벡터를 다른 벡터에 투영한 벡터를 구할 수 있다.

투영은 쉽게 말해 **"한 벡터를 다른 벡터 방향으로 비춘 그림자"** 라고 생각하면 이해가 쉽다.
벡터 b가 전체적으로 어떤 방향을 향하고 있더라도, 그중에서 a 방향으로 기여하는 부분만 뽑아내는 것이다.

만약 햇빛이 특정 방향(벡터 a)으로 비춘다면, 물체(벡터 b)가 만든 그림자가 바로 **b 의 a 방향 투영**이다.

**공식**
두 벡터 **a(햇빛)** 와 **b(물체)** 가 있을 때,

##### 투영 크기(스칼라)
$$proj\_len = \frac{a⋅b}{∥a∥}$$
-> **b**가 **a**방향으로 얼마나 긴지를 나타내는 스칼라 값이다​

##### 투영 벡터(a 방향으로의 실제 벡터)
$$proj_a​(b)= \frac{a⋅b​}{∥a∥^2}a$$
-> 방향은 **a**와 같고, 길이는 **b의 a방향 성분** 길이.

- b가 a 방향과 완전히 같으면, 투영은 b 자체가 된다.
- b가 a와 직각이면, 투영은 0벡터(길이가 0).
- b가 a 반대 방향이면, 투영은 a와 반대 방향의 벡터. 

**내용을 정리해보자면,**
- 투영은 한 벡터의 특정 방향 선분을 뽑는 것이고,
- 계산은 내적(dot product)를 이용한다.
- 결과가 숫자면 **길이**이고, 벡터면 **방향이 포함된 성분**이다.

##### (실습) 투영을 RealityKit / ARKit에서 활용해보자
- **표면 위 물체 움직임**: 물체의 속도 벡터를 표면 방향으로 투영해, 실제 이동 가능한 방향 성분만 계산.
    
- **카메라 forward 성분 추출**: 플레이어 움직임이 카메라 방향 성분인지, 측면 성분인지 구분.
    
- **빛 반사 계산**: 빛 벡터를 표면 법선에 투영하여 확산광, 반사광 계산.


### 벡터 외적(Cross Product)
>두 벡터의 성분을 활용하여 새로운 벡터를 생성하는 연산

벡터는 3차원 공간에서만 정의할 수 있는 개념이고, **외적의 결과값은 벡터**이다.

#### 외적 구하는 공식
벡터 $\vec a = (a_1, a_2, a_3)$,  $\vec b = (b_1, b_2, b_3)$가 있을 때, 외적은 다음과 같다.
$$\vec a \space \cdot \space \vec b = (a_2b_3 - a_3b_2, \space a_3b_1 - a_1b_3, \space a_1b_2 \space - a_2b_1)$$

공식만 보면 다소 복잡해 보일 수 있지만, 아래의 방법으로 계산하면 간단하게 구할 수 있다.

![[Pasted image 20250814004918.png]]

두 개의 벡터 값들을 차례대로 2회씩 나열하고, 처음과 마지막 열은 제외한다.
그 후 X 자로 곱한 값들을 빼주면 결과값(벡터)의 성분이 차례대로 나오게 된다.

그런데, 앞에서 **벡터**는 어떤 특징을 가지고 있다고 얘기했을까 ?

벡터는 **크기**와 **방향**을 가진다.

그렇기에 외적의 결과값 또한 벡터이므로 **크기**와 **방향**을 가질 것이다.

#### 그렇다면, 외적의 크기와 방향은 어떻게 구할까 ?

**외적의 크기**
> 벡터 $\vec a$와 $\vec b$가 있을 때, 두 벡터의 **외적의 크기**는 두 벡터를 변으로 하는 **평행 사변형의 넓이**이다.

![[Pasted image 20250814003741.png]]

외적의 크기를 구하는 공식은 아래와 같다.
$$|\vec a \cdot \vec b| = 평행사변형의 넓이 = |\vec a||\vec b| \sin \theta$$
밑변의 길이가 $|\vec a|$라면, 높이는 $|\vec b| \sin \theta$가 된다.


**외적의 방향**
> 벡터 $\vec a$와 $\vec b$에 동시에 수직인 방향을 가지게 된다.
![[Pasted image 20250814004340.png]]

벡터 $\vec a$에 대한 외적 $\vec b$의 결과값인 벡터의 방향은 두 벡터에 대해서 **수직이다.**
그런데 수직인 방향은 위도 있고, 아래도 있을 것이다.

이는 **오른손 법칙**을 통해 구할 수 있다.
처음 벡터 $\vec a$의 방향을 손으로 가리키고, 뒤에 오는 벡터 $\vec b$의 방향으로 손바닥을 말게 되면 **엄지손가락의 방향**이 두 벡터의 **외적의 방향**이다.

#### 그래픽스에서 활용 예

- **법선 벡터 생성**:  
    삼각형의 두 변 벡터 $v_1, v_2$의 외적 → 표면 법선
    
- **회전축 구하기**:  
    두 방향 벡터가 주어졌을 때, 외적은 회전해야 할 축을 알려줌
    
- **손잡이 방향 계산**:  
    예를 들어 캐릭터가 오른손을 앞으로 뻗었을 때 위쪽 방향 계산


### 벡터 공간(Vector Space)
> 벡터 공간(선형 공간)은 벡터라고 하는 객체의 집합으로, 벡터는 서로 더해지고 스칼라라고 하는 숫자로 곱해질 수 있다.

위키피디아에서 벡터 공간의 정의에 따르면 **선형 공간**이라고 칭하고 있다.

벡터는 **벡터 공간**의 원소이므로 선형성을 가지고, 서로 더하거나 스칼라를 곱해서 길이를 조절할 수 있다.

결과적으로 벡터의 정의 자체가 **선형성**을 가지는 물체이다.

![[Pasted image 20250813163204.png]]
[이미지 출처: https://m.blog.naver.com/ideugu/221401473118?recommendTrackingCode=2]

원점을 기준으로 무수히 많은 벡터가 있다면, 위와 같이 원점을 중심으로 어떠한 공간이 형성될 것이다.
위의 이미지가 벡터 공간이라고 생각한다면, 무수히 많은 벡터에서 **서로 영향을 주지 못하는 벡터가 존재할 것이다**

대각선으로 뻗은 화살표들은 각 x축과 y축에 해당하는 화살표의 조합으로 만들 수 있지만,
y축을 가리키는 화살표는 x축 화살표의 도움을 받아 만들 수 없다.
이처럼 서로 연관이 없는 화살표를 **선형 독립**이라고 한다.

또한, x축 y축 화살표와 같이 공간을 구성하는 기본 요소가 되는 벡터를 **기저 벡터(Basis Vector)** 라고 한다.
여기서 크기가 1인 벡터를 특별히 **표준 기저 벡터(Standard Basis Vector)** 라고 한다.

**표준 기저 벡터**를 사용하면 x축 y축의 2차원 공간에 존재하는 모든 벡터를 수식으로 표현할 수 있으며,
이를 **선형 조합(linear combination)** 이라고 한다.
$$v = ax + by$$
>$V$= 해당 공간에 존재하는 벡터, $x$  = $x$축 표준 기저 벡터, $y$  = $y$축 표준 기저 벡터


표준 기저 벡터 $x$와 $y$에 스칼라 곱을 통해서 벡터를 생성하는 과정을 수학적으로 스팬(span)한다고 표현한다.

스팬된 벡터는 항상 벡터 공간 V에 속하게 되며, 이는 곧 스팬될 수 있는 모든 벡터들이 모두 모인 곳이 **벡터 공간**이 되는 것이다. 이를 수학적으로 표현하면 다음과 같다.
$$span[x,y] = V$$

해당 벡터 공간에서의 **기저 벡터**는 $x$와 $y$ 두 개 이므로 이를 **2차원 벡터 공간**이라고 한다.
(세 개면 3차원, 네 개면 4차원 ...)

>또한, 표준 기저 벡터에서 사용하는 스칼라 a, b가 사용하는 수 체계에 따라 벡터 공간 V의 크기가 정해진다.

스칼라의 수 체계는 일반적으로 **실수**를 사용한다.
만일 a와 b의 크기가 실수 0과 1사이로 한정된다면, **벡터 공간의 크기**는 다음과 같을 것이다.
![[Pasted image 20250814012834.png]]


### RealityKit에서 실수 체계
RealityKit의 `SIMD`벡터 타입(`SIMD3<Float>, SIMD4<Float>`)이나 `Transform`구조체의 좌표값은 대부분 `Float`을 사용한다.

앞서서 벡터를 스팬하는데 사용하는 스칼라의 수 체계는 일반적으로 **실수**를 사용한다고 하였다.
스칼라가 속하는 수 체계에 따라 벡터 공간의 범위와 성격이 정해지므로, 컴퓨터가 실수를 다루는 방법의 이해는
컴퓨터로 벡터를 표현하는 방법의 이해로 이어지게 된다.

컴퓨터에서 실수를 표현하는 방법은 크게 `float`와 `double` **두 가지**로 이루어져 있다.

`float`는 **32비트**를 사용하는 수 체계이며 단일 정밀도라고 한다. 그 **두 배**인 64비트를 사용하는 `double`은 더욱 정밀한 실수 체계를 표현할 수 있다.

정밀한 계산이 요규되는 공학이나 과학 영역에서는 `double`을 사용하는 것이 일반적이지만,
게임 그래픽스에서 `double`을 사용하여 게임을 실시간 시뮬레이션 하기에는 데이터들이 방대해지고 연산이 많아지기 때문에 32비트 단일 정밀도를 가지는 `float`체계를 사용해 수를 표시한다.

사실 `float`을 사용한다는 것은 듬성듬성하고 오차가 많은 수 체계를 사용한다는 것을 의미한다.
실제로 흔히 사용하는 0.1이라는 값은 `float`형식에서 정확하게 표현할 수 없기에 게임 그래픽스에서 다루는 벡터는 오차가 많은 불완전한 체계이다.

다만, 이러한 오차는 인간의 눈으로는 인지하기 힘든 작은 크기이기 때문에 문제 없이 사용하고 있을 뿐이다.

예를 들어 (1, 1)인 벡터 A에 (99, 99)를 더하여 (100, 100)을 만든 뒤 제곱근을 취하여 (10, 10)으로 만든 뒤에 0.1을 곱하게 되면 원래 값인 (1, 1)이 될 것이다. 하지만 `float`체계로 이를 연산할 경우 오차로 인해 원래의 벡터 A와 같은 값을 가진다고 보장할 수 없다. 그렇기 때문에 두 벡터를 비교할 때에 미세한 오차는 허용해 주어야 한다.
언리얼에서는 허용하는 오차 범위를 위해 `KINDA_SMALL_NUMBER`라는 매크로를 제공하고,
유니티에서는 `mathf`에서 `Epsilon`변수를 제공한다.

이처럼 `float`체계를 사용해 컴퓨터가 만들어내는 벡터 공간은 수학적으로 완벽한 실수 체계가 만들어내는 무결한 멕터 공간과 달리 인간의 눈에 안보이는 무수히 많은 구멍들이 뚫려있는 어설픈 벡터 공간이라고 할 수 있다.

### (추가예정) RealityKit을 통해 벡터 시각화하기



### 참고 자료
**네이버 블로그** https://m.blog.naver.com/ideugu
**네이버 블로그** https://dippingtodeepening.tistory.com/21
**인공지능을 위한 선형대수 기초** https://wikidocs.net/214412
**유튜브** https://www.youtube.com/watch?v=3GsBaTqxcjM&ab_channe=설레는수학
**유튜브** 


## 행렬(Matrix)
> 숫자나 수식을 행(row)과 열(column)로 배열한 것

행렬의 개념에 대해 수학적으로 깊게 파고들기보다, 개념만 간단하게 알아보고 **RealityKit과 ARKit에서 행렬이 어떻게 활용되는지** 알아볼 것이다.

행렬의 크기는 **행의 개수 x 열의 개수**로 표시한다.
행이 2개, 열이2개인 행렬의 경우 **2x2행렬**

**행렬 상등에 관한 정의**
두 행렬이 같은 지를 판별하는 방법은 두 행렬의 **모든 성분이 같으면** 서로 같다고 정의한다.

### 행렬의 기본적인 연산 
#### 행렬의 덧셈,뺄셈
다음과 같이 (2x2)의 두 행렬 A, B가 있을 때 같은 성분끼리 더해주면 된다.
(뺄셈의 경우 덧셈과 똑같은 방법으로 같은 성분을 빼주면 된다.)

$$
A =
\begin{bmatrix}
1 & 2 \\
0 & 3
\end{bmatrix},
\quad
B =
\begin{bmatrix}
-2 & 1 \\
1 & 0
\end{bmatrix}
$$

$$
A + B =
\begin{bmatrix}
1 + (-2) & 2 + 1 \\
0 + 1 & 3 + 0
\end{bmatrix}
=
\begin{bmatrix}
-1 & 3 \\
1 & 3
\end{bmatrix}
$$


#### 행렬의 상수배
위의 행렬 A에 상수 2를 곱해줄 경우 각 성분마다 상수를 곱해주면 된다.
$$2A = {2\cdot1 \space\space 2\cdot2 \brack 2\cdot0 \space\space 2\cdot3} = {2 \space\space 4\brack0 \space\space 6}$$

>주의해야 할 부분은,
>행렬의 덧셈은 **행렬과 행렬**의 연산이지만,
>행렬의 상수배는 **행렬과 상수**의 연산이다.



#### 행렬의 곱셈
행렬끼리의 곱셈을 하기 위해서는 **전제조건**이 필요하다.
행렬 **A**와 **B**를 곱하는 경우 **A의 열의 개수**와 **B의 행의 개수**가 동일해야 한다.

행렬 **A**가 `m x n` 행렬이고 **B**가 `n x r`행렬이라면, 
곱한 결과 행렬 **AB**는 `m x r`행렬이 된다.

**결과적으로**, 곱한 결과 행렬의 **행의 개수는 A와 같고**, **열의 개수는 B와 같다**.

왜 그런지 행렬끼리 곱셈을 해보며 알아보자.

>아래와 같이 2x3 행렬 A와 3x2 행렬 B가 있다.
$$A = \begin{bmatrix}
a_1 & a_2 & a_3 \\
a_4 & a_5 & a_6
\end{bmatrix},
\quad
B = \begin{bmatrix}
b_1 & b_2 \\
b_3 & b_4 \\
b_5 & b_6
\end{bmatrix}$$

행렬을 곱하는 방법은, A의 1행에 있는 모든 성분과 B의 1열에 있는 모든 성분들을 각각 위치에 맞게 곱한 값들을 모두 더해주면 1행 1열의 값이 나온다.

$$[AB]_{11} = a_1b_1 + a_2b_3 + a_3b_5$$

AB의 1행 2열에 있는 값을 구하려면, A의 1행에 있는 값들과 B의 2열에 있는 값들을 위의 방식으로 더해주면 된다.
이와 같은 방식으로 모든 연산을 마치고 나면

$$AB = \begin{bmatrix}
(a_1b_1 + a_2b_3 + a_3b_5) & (a_1b_2 + a_2b_4 + a_3b_6)\\
(a_4b_1 + a_5b_3 + a_6b_5) & (a_4b_2 + a_5b_4 + a_6b_6)
\end{bmatrix}
$$

결과적으로 **2 x 2크기**의 행렬이 나오게 된다.

### 선형 변환(Linear Transformation)
> 벡터 공간을 구성하는 기저 벡터의 길이를 조정해 벡터 공간을 변형

잘 알고있는 **함수**의 개념을 선형 대수학에서는 **변환(Transformation)** 이라는 용어를 사용한다.
즉, **변환**은 **어떠한 벡터를 행렬에 입력**하면 **새로운 벡터를 출력**하는 것이다.
그 중에서도 **선형 변환**은 균등한 변환만을 다루는 개념이다.
![[선형변환.gif]]
선형 변환은 위와 같이 격자가 직선을 유지하며 균등하게 변화하며, **원점은 고정**되어 있어야 한다.

앞서 말했듯이 2차원 평면상의 **모든 벡터는** **기저벡터의 선형결합으로 표기**가 된다.
따라서 2차원 평면에 존재하는 어떤 임의의 벡터가 **선형변환**하여 다른 벡터로 바뀌면 **해당 벡터와 해당 벡터의 기저벡터들 모두 함께 변환된다**.

선형 변환은 이동을 제외한 회전, 스케일, 전단(shear), 정사영(projection)을 다룬다.
대신 **동차좌표**를 사용하면 이동까지 하나의 `4x4행렬`로 표현 가능하다.

여기서 `4x4행렬`은 어떤 벡터를 **다른 벡터로 변환해주는 규칙**을 의미한다.


### 행렬식(Determinant)
>행렬식(determinant)은 정사각행렬에 대해 정의되는 하나의 수(scalar).
> det(A) 또는 |A|로 표기.

#### 행렬식 계산 방법
**행렬식**은 2차원 행렬에서는 아래와 같은 방식으로 구해진다.

$$A = \begin{bmatrix}
a & b \\
c & d
\end{bmatrix} , det(A) = ad - bc$$

**2차원 행렬**은 단순히 `ad - bc`이지만, 3차원부터는 점점 복잡해지기 시작하므로 2차원 행렬에 대한 계산 방법만 알아보자.

왜냐하면, **컴퓨터 그래픽스에서 다루는 행렬**은 **모두 직교 행렬**이기 때문에 몰라도 구현하는데 지장은 없다.
*(직교 행렬에서는 역행렬을 구할 때 다른 방법을 사용한다)*

#### 행렬식의 의미
앞에 선형변환에서 말했듯이 행렬은 도형이 아닌 **변환(Transformation)** 을 의미한다.
**행렬식**은 단순한 수치가 아니라 **선형 변환**이 공간을 얼마나 **"늘리거나 줄이고"** 또 **"뒤집는지"** 를 나타내는 **척도**
이다.

또한, 행렬식을 통해 어떤 행렬에 대한 **역행렬이 존재하는지 여부를 판별**할 수 있다.
**행렬식 값이 0이면** 그 행렬의 **역행렬은 존재하지 않는다**

`2 x 2`행렬에서 행렬식은 **2D 평면에서 면적**(scale factor)를 의미하고,
`3 x 3`행렬에서 행렬식은 **3D 공간에서 부피**(scale factor)를 의미한다.

즉,
- $|det(A)| = 2$ -> 변환된 도형의 면적/부피가 2배
- $|det(A)| = 0.5$ -> 변환된 도형의 면적/부피가 절반으로 축소
- $det(A) < 0$ -> 공간이 뒤집힘(reflection)



#### 그래픽스에서 행렬식의 활용
##### 역행렬 존재 여부
행렬식은 그래픽스에서 **해당 변환이 정상적인지, 뒤집혔는지, 비정삭적인지**를 판별하는 데 핵심이다.

위에서 행렬식을 통해서 역행렬 존재 여부를 판별할 수 있다고 했다.
행렬식의 값이 0이면 역행렬이 존재하지 않으므로, 해당 변환이 공간을 찌부려서 되돌릴 수 없다.
	예) 3D 객체를 한 평면으로 납작하게 눌러버림

반대로 $det(A) \ne 0$ 이면 행렬이 역행렬을 가지므로 **되돌릴 수 있는 변환**이다.

##### 스케일 크기 추정
3D 모델이 transform 행렬을 통해 스케일링 되었을 때, 행렬식의 절댓값이 전체 부피가 얼마나 바뀌었는지 알려준다.
- $|det(M)| = 1$ -> 부피 보존 (순수 회전﹒이동)
- $|det(M)| \ne 1$ -> 스케일 변환 보함

##### 좌표계의 방향성(오른손/왼손 좌표계)
- $det(M) > 0$ -> 오른손 좌표계 유지
- $det(M) < 0$ -> 왼손 좌표계로 뒤집힘 (예: reflection, 미러링 효과)
또한, **삼각형의 앞뒤 면을 구분(Backface Culling)** 할 때도 중요하다.



#### RealityKit을 활용한 예제




### 역행렬



### 단위 행렬, 회전 행렬, 스케일 행렬




### 동차 좌표계



#### RealityKit/ARKit에서 행렬을 활용한 예제
**큐브 이동, 회전, 크기 조절하기**





